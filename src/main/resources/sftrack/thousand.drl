//created on: Jul 11, 2013
package sftrack;

import java.util.ArrayList;
import java.util.List;
import sftrack.CaseData.LitiParty;
import sftrack.Ontology;
//declare any global variables here
global LtUtil ut;
global Ontology onto;

rule "dicklook"
	when
		p1: Phrase(synType==null)
		p2: DictPhrase(match(p1) !=null)
	then
		ut.print("Find dicklook: " + p1);
		Phrase ph = p2.match(p1);
		ut.printPhrase(ph);
		insert(ph);
end

rule "dicklook_rescue"	
	salience -3000
	// for Amazon.com, Inc., sometimes only "Amazon" appear in the text.
	when
		p1: Phrase(synType==null)
		p2: DictPhrase(matchFirstOne(p1) !=null)
		not Phrase(synType != null, begToken<=p1.begToken, endToken >= p1.endToken)
	then
		ut.print("Find dicklook_rescue: " + p1);
		Phrase ph = p2.matchFirstOne(p1);
		ut.printPhrase(ph);
		insert(ph);
end

rule "number_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_NUMBER)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "letter_1"	// Single letters, like A, B, .... in "Exhibit A and B"
	when
		p: Phrase(synType==null, text.length()==1, sentence.get(begToken).type == LexToken.LEX_WORD)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "LETT", g);
		insert(ph);
		ut.printPhrase(ph);
end



rule "date_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_DATE)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("DateValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "casenumber_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_CASENUMBER)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("CaseNumber"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Number_In_CaseNumber"	// 330 in 1:11-cv-00315-SLR
	when
		p1: Phrase(synType=="NUMP", head.isKindOf("NumberValue"), text.length() <= 4) 
		p2: Phrase(synType=="PRP", head.isKindOf("in"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && lk2.getArg2().isInstanceOf("CaseNumber"))
	then
		ut.print("Find Number_In_CaseNumber: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		ph.setSynType("NUMREF");
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "Number_In_CaseNumber_in_braces"	// (330 in 1:11-cv-00315-SLR)
	when
		p1: Phrase(synType=="SYMBOL", text=="(") 
		p2: Phrase(synType=="NUMREF", begToken==p1.endToken) 
		p3: Phrase(synType=="SYMBOL", text==")", begToken==p2.endToken)
	then
		ut.print("Find Number_In_CaseNumber_in_braces: " + p1 + ", " + p2 + ", " + p3 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);		
		Phrase ph = new Phrase(pl, "NUMREF", p2.getGraph());
			insert(ph);
	 	ut.printPhrase(ph);
end


rule "time_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_TIME)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("MinuteValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "number_2"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_DIGIT)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_name"	// July 4, 2013
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
		p3: Phrase(synType=="SYMBOL", text==",", begToken==p2.endToken)
		p4: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4, begToken==p3.endToken)
	then
		ut.print("Find month_date_year: " + p1 + ", " + p2 + ", " + p3 + ", " + p4);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		int monthnum = LtUtil.getMonthNumber(p1.getHead().getName());
		Entity e1 = new Entity(""+ monthnum, onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p4.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p4.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, p3, p4, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "DateValue_MinuteValue"	// Conference set for 1/5/2010 01:00 PM
	when
		p1: Phrase(synType=="TIMEP", g1 : graph, graph.topLink==null, head.isKindOf("DateValue"))
		p2: Phrase(synType=="TIMEP", g2 : graph, graph.topLink==null, head.isKindOf("MinuteValue"), begToken==p1.endToken)
	then
		ut.print("Find DateValue_MinuteValue: " + p1 + ", " + p2);
		Entity e0 = new Entity("TimeValue", onto);
		ERGraph g = new ERGraph(e0);
		g.merge(g1);
		g.merge(g2);
		Link lk = new Link("MinuteValueOf", e0, p2.getHead());
		g.addLink(lk);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_slash"	// 07/04/2013
	when
		p1: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2)
		ps1: Phrase(synType=="SYMBOL", text=="/"||text=="-", begToken==p1.endToken)
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==ps1.endToken)
		ps2: Phrase(synType=="SYMBOL", text=="/"||text=="-", begToken==p2.endToken)
		p3: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4||graph.head.name.length ==2, begToken==ps2.endToken)
	then
		ut.print("Find month_date_year_slash: " + p1 + ps1 + p2 + ps2 + p3);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = new Entity(p1.getText(), onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p3.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p3.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(ps1);
		pl.add(p2);
		pl.add(ps2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_space"	//Official Transcript of Trial Day 4 held on 10 14 11 before Judge Sleet.
	when
		p1: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2)
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
		p3: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==2 || graph.head.name.length ==4 , begToken==p2.endToken)
	then
		ut.print("Find month_date_year_space: " + p1 + ", " + p2 + ", " + p3);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = new Entity(p1.getText(), onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p3.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p3.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date"	// July 14
	salience -100
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
//		p2: Phrase(synType==null, begToken==p1.endToken, sentence.get(begToken).type == LexToken.LEX_DIGIT)
		(not Phrase(synType=="TIMEP", graph.head.isKindOf("DateValue"), begToken==p1.begToken))
	then
		ut.print("Find month_date: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = p1.getGraph().getHead();// month
		Entity e2 = new Entity(p2.getText(), new Entity("DateNumber", onto), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "month_year"	// October 2010
	salience -100
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4, begToken==p1.endToken)
//		p2: Phrase(synType==null, begToken==p1.endToken, sentence.get(begToken).type == LexToken.LEX_DIGIT)
		(not Phrase(synType=="TIMEP", graph.head.isKindOf("DateValue"), begToken==p1.begToken))
	then
		ut.print("Find month_date: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = p1.getGraph().getHead();// month
		Entity e2 = new Entity(p2.getText(), new Entity("DateNumber", onto), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("YearValueOf", e2, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
	 	ut.printPhrase(ph);
end


rule "Weekday_Monthday_1"
	when
		p1: Phrase(synType=="TIMEP", graph.links==null, head.isKindOf("DayOfWeek"))
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolComma"), begToken==p1.endToken)
		p3: Phrase(synType=="TIMEP", head.isKindOf("MonthDateValue"), begToken==p2.endToken)
	then
		ut.print("Find Weekday_Monthday_1: " + p1 + ", " + p2 + ", " + p3);
		Link r = new Link("DayOfWeekOf", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p2, p3, r, 2);
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "Two_Bracket_Serial"
	when
		p1: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolLeftBracket"))
		p2: Phrase(synType=="NUMP", head.isKindOf("NumberValue"), begToken==p1.endToken)
		p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolRightBracket"), begToken==p2.endToken)
	then
		ut.print("Find Two_Bracket_Serial: " + p1 + ", " + p2 + ", " + p3);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
	 	ERGraph g = new ERGraph(new Entity(p2.getText(), onto.getEntity("SerialValue"), Entity.TYPE_INSTANCE, onto, p2.getBegToken()));
		Phrase ph = new Phrase(pl, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end


rule "One_Bracket_Serial"
	when
		p2: Phrase(synType=="NUMP", text.length()==1, head.isKindOf("NumberValue"))
		p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolRightBracket"), begToken==p2.endToken)
		not Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolLeftBracket"), p2.begToken - endToken < 3 && p2.begToken - endToken >=0)
	then
		ut.print("Find One_Bracket_Serial: " + p2 + ", " + p3);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p2);
		pl.add(p3);
	 	ERGraph g = new ERGraph(new Entity(p2.getText(), onto.getEntity("SerialValue"), Entity.TYPE_INSTANCE, onto, p2.getBegToken()));
		Phrase ph = new Phrase(pl, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "Serial_NP"
	when
		p1: Phrase(synType=="NUMP", head.isKindOf("SerialValue"))
		p2: Phrase(synType=="NP", begToken==p1.endToken)
	then
		ut.print("Find Serial_NP: " + p1 + ", " + p2);
		Link r = new Link("hasSerial", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "Weekday_Monthday_2"
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, head.isKindOf("DayOfWeek"))
		p3: Phrase(synType=="TIMEP", graph.head.isKindOf("MonthDateValue"), begToken==p1.endToken)
	then
		ut.print("Find Weekday_Monthday_2: " + p1 + ", " + p3);
		Link r = new Link("DayOfWeekOf", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p3, r, 2);
		insert(ph);
	 	ut.printPhrase(ph);
end



rule "abbreviation with dot"
	when
		p1: Phrase(synType=="NP"||synType=="ORGSUFFIX", graph.topLink==null, graph.head.isKindOf("Abbreviation") )
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolDot") , begToken==p1.endToken)
	then
		ut.print("Find abbreviation with dot: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, "Abbreviation", 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "OrgCo_Suffix"
	salience -200
	when
		p1: Phrase(synType == "NP", graph.topLink==null, head.isKindOf("OrgCo"));
		p2: Phrase(synType == "ORGSUFFIX", begToken==p1.endToken)
		not (Phrase(synType=="NP", head.isKindOf("OrgCo"), begToken<=p1.begToken, endToken>=p2.endToken))
	then
		ut.print("Find OrgCo_Suffix: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "OrgCo_Comma_Suffix"
	when
		p1: Phrase(synType=="NP", graph.topLink==null, graph.head.isKindOf("OrgCo") )
		p12: Phrase(synType=="SYMBOL", graph.topLink==null, head.isInstanceOf("SymbolComma"), begToken==p1.endToken  )
		p2: Phrase(synType=="ORGSUFFIX", graph.topLink==null, graph.head.isKindOf("Abbreviation"), begToken==p12.endToken )
		not (Phrase(synType=="NP", head.isKindOf("OrgCo"), begToken<=p1.begToken, endToken>=p2.endToken))
	then
		ut.print("Find OrgCo_Comma_Suffix: " + p1 + ", " + p12 + ", " + p2 );
		Phrase ph = new Phrase(p1, p12, p2, null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "OrgCo_infer_name"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isKindOf("OrgCo"), !lastPhrase.head.isKindOf("Abbreviation"), graph.links ==null);
// 		p3: Phrase(synType != null, begToken > p1.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
		p3: Phrase(synType=="ORGSUFFIX", head.isKindOf("Abbreviation"), begToken > p1.endToken + 1)
		not Phrase(synType=="ORGSUFFIX", head.isKindOf("Abbreviation"), begToken >= p1.begToken, endToken < p3.begToken)
// 		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2) 
 		not Phrase(synType != null, begToken < p3.begToken, endToken > p3.begToken)
 		not Phrase(synType == "PRP", begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find OrgCo_infer_name: " + p1 + ", " + p3 );
		ut.printPhrase(p1);
		ut.printPhrase(p3);
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getBegToken();
		int eIndex = p3.getEndToken();
//		System.err.println("bIndex:" + bIndex + ", eIndex: " + eIndex + ", tks.size: " + tks.size());
//		System.err.println("tks: " + tks);
		LexToken btk = tks.get(bIndex);
		// check junk got suspected as name parts:
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("filed") || txt.equals("by")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String partyName;
			if(eIndex >= tks.size()){
				partyName = sent.substring(btk.getStart()).trim();
			} else {
				LexToken etk = tks.get(eIndex);
				partyName = sent.substring(btk.getStart(), etk.getStart()).trim();
			}
			ut.print("(" + bIndex + ", " + eIndex + ") " +  partyName);
			onto.createNewParty(partyName, onto, drools.getWorkingMemory(), p1.getHead());
		}
end
rule "NP_AND_NP"
	salience 100
	when
		p1: Phrase(synType=="NP", g1 : graph)
		p2: Phrase(text.equalsIgnoreCase("and"), synType=="CONJ", begToken==p1.endToken)
		p3: Phrase(synType=="NP", g2 : graph, begToken==p2.endToken)
		eval(p1.similar(p3))
	then
		ut.print("Find NP_AND_NP for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, p1.getHead().getName() + "AND" +  p3.getHead().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "NP_VP_Passive"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive")) !=null, 
				graph.containLink("ugoerOfProc", null, head) ==null)
		exists Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VP_Passive: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "BE_VP_past_Passive"
	when
		p1: Phrase(synType=="VP", head.isKindOf("Be"), !graph.containLinkExcept(head, "hasAttribute", "1"));
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" )
	then
		ut.print("Find BE_VP_past_Passive: " + p1 + ", " + p2 );
		Entity e = onto.getEntity("StatusPassive");
		Link r = new Link("hasAttribute", p2.getHead(), e);
		ERGraph g = p2.getGraph().duplicate();
		g.addLink(r);
		g.setTopLink(r);
		Phrase ph = new Phrase(p1, p2, "VP", g);
		ph.setTense("past");
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_IS_ADJP"	// CASE MANAGEMENT CONFERENCE ON JUN-07-2017 IS OFF CALENDAR
	when
		p1: Phrase(synType=="NP", head.isKindOf("Process"))
		p0: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("Be"));
		p2: Phrase(synType=="ADJP", begToken==p0.endToken)
//		r : Link(type=="valueOf", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find NP_IS_ADJP: " + p1 + ", " + p0 + ", " + p2 );
		Link lk = new Link("hasAttribute", p1.getHead(), p2.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), lk, 1);
		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
		ph.setTense(p0.getTense());
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_IS_NP_1"	// Deadline is May 1, 2012
	when
		p1: Phrase(synType=="NP")
		p0: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("Be"));
		p2: Phrase(synType=="NP"||synType=="TIMEP", begToken==p0.endToken, head.isKindOf("EntityValue"))
		r : Link(type=="valueOf", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find NP_IS_NP: " + p1 + ", " + p0 + ", " + p2 );
		Link lk = new Link("valueOf", p2.getHead(), p1.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), lk, 1);
		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
		ph.setTense(p0.getTense());
		ph.setSubject(p1);
			insert(ph);
			ut.printPhrase(ph);
end

rule "NP_IS_NP_2" // the reverse of NP_IS_NP_1: May 1, 2012 is the deadline
	when
		p1: Phrase(synType=="NP"||synType=="TIMEP", head.isKindOf("EntityValue"))
		p0: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("Be"));
		p2: Phrase(synType=="NP", begToken==p0.endToken)
		r : Link(type=="valueOf", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_IS_NP: " + p1 + ", " + p0 + ", " + p2 );
		Link lk = new Link("valueOf", p1.getHead(), p2.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), lk, 1);
		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
		ph.setTense(p0.getTense());
		ph.setSubject(p1);
			insert(ph);
			ut.printPhrase(ph);
end

rule "NP_ModifiedBy_VP" // NOTICE requesting Clerk to remove Tara C. Stuart as co-counsel.
	when
		p1: Phrase(synType=="NP", graph.containLink("hasDET", head, null)==null
				, graph.containLink("hasAttribute", head, onto.getEntity("Process"))==null
//				, graph.containLink("ugoerOfProc", head, null)==null
				)
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" || tense=="ing", 
				graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive"))==null,	 // avoid combining "amended answer" + "be filed"
				graph.containLink("ugoerOfProc", null, head)==null	 // order, amending D.I. 49 scheduling order
			)
 
	 //		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" || tense=="ing", graph.containLink("ugoerOfProc", null, head)==null)// use past tense
		exists Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_ModifiedBy_VP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
//		ph.transferLinks("PRPRelation", p2.getHead(), p1.getHead());
		insert(ph);
		ut.printPhrase(ph);
end
/*
rule "NP_Transfer_filed_by"
	salience 500
	when
		p1: Phrase(synType=="NP", head.isKindOf("Document"), g: graph, graph.containLink("hasContent", head, null)==null)
		(or
				eval( (g.containLink("byAgent", p1.getHead(), null)==null) && (g.containLink("byAgent", (Entity)null, null) != null))
				eval( !g.containLinkKind("ugoerOfProc", p1.getHead(), onto.getEntity("ProcFileDoc")) && g.containLinkKind("ugoerOfProc", null, onto.getEntity("ProcFileDoc")))
			)
	then
		ut.print("Find NP_Transfer_filed_by: " + p1);
		boolean b = p1.transferFiledBy();
		if(b){
			update(p1);
			ut.printPhrase(p1);
		}
end
*/


rule "TO_VP"
	when
		p1: Phrase(synType=="PARTICLE", head.isKindOf("ToInfinitive"), graph.topLink == null)
		p2: Phrase(synType=="VP", begToken==p1.endToken)// use past tense
	then
		ut.print("Find TO_VP: " + p1 + ", " + p2 );
	   Link r = new Link("ToInfinitive", p1.getHead(), p2.getHead());
		 Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_TOVP"
	when
		p1: Phrase(synType=="NP", headLast(), graph.containLink("hasOwner", head, null)==null, graph.containLink("hasDET", head, null)==null)
		p2: Phrase(synType=="PARTICLE", head.isKindOf("ToInfinitive"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="ToInfinitive")
 	then
		ut.print("Find NP_TOVP: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end


rule "ADVP_VP"
	when
		p1: Phrase(synType=="ADVP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, !graph.containLinkNot("hasAttribute", p1.getHead(), null))
	then
		ut.print("Find ADVP_VP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_ADVP"
	when
		p1: Phrase(synType=="NP", !graph.containLinkNot("hasAttribute", p1.getHead(), null))
		p2: Phrase(synType=="ADVP", text.equalsIgnoreCase("only"), begToken==p1.endToken)
	then
		ut.print("Find NP_ADVP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end


rule "NP_VP"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", tense=="present", graph.containLink("agentOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		r : Link(type=="agentOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VP: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, r, 2);// result is VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_VPing"	//STIPULATION Governing Post-Trial Submissions
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", tense=="ing", graph.containLink("agentOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		r : Link(type=="agentOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VPing: " + p1 + ", " + p2 );
		Link lk = new Link("agentOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, lk, 1); // result is NP, This is similar to rule NP_ModifiedBy_VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "VPing_NP"	//documents will be claimed by the FILING party/attorney 
	when
		p1: Phrase(synType=="VP", tense=="ing", graph.containLink("agentOfProc", null, head)==null, graph.containLink("ugoerOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null)
		p2: Phrase(synType=="NP", begToken==p1.endToken)
		r : Link(type=="agentOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPing_NP: " + p1 + ", " + p2 );
		Link lk = new Link("agentOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, lk, 2); // result is NP, This is similar to rule NP_ModifiedBy_VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_have_been_VP"	// have been is opposite of to be
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="ASSISTVB", begToken==p1.endToken)
		p3: Phrase(synType=="VP", tense=="past", begToken==p2.endToken)
	then
		ut.print("Find NP_have_been_VP: " + p1 + ", " + p2 + ", " + p3);
		Link lk = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p3.getGraph(), lk, 2);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "VP", g);
		ph.setSubject(p1);
		ph.setTense("past");
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_NP"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="NP", graph.containLink("agentOfProc", null, head)==null, 
//		graph.containLink("ugoerOfProc", head, null)==null, 
					graph.containLink("re", head, null)==null, begToken==p1.endToken)
		not (
				eval(p1.getEndToken() - p1.getBegToken() > 3) and
				eval(p1.getGraph().containLinkKind("PRPRelation", p1.getHead(), null))
			)
		exists Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VP_NP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
//		if(p1.getTense().equals("past")){
		// "revised order"=> (1) Judge revised order; (2) Judge gave us the revised order.
		// should have no "the", "their", etc in p2. I'll add these restrictions later.
//			ph = new Phrase(p1, p2, r, 2);	// NP
//			insert(ph);
//			ut.printPhrase(ph);
//		}
end

rule "VP_TIMEP"	// summons served JUN-17-2012, conference held MAY-06-2016
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, tense=="past")
		p2: Phrase(synType=="TIMEP", graph.containLink("re", head, null)==null, begToken==p1.endToken)
	then
		ut.print("Find VP_TIMEP: " + p1 + ", " + p2 );
		Link r = new Link("on", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
end

rule "VPP_NP_TIMEP"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="TIMEP", graph.containLink("agentOfProc", null, head)==null, 
					graph.containLink("re", head, null)==null, begToken==p1.endToken)
		exists Link(type=="secondObjectOf", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPP_NP_TIMEP: " + p1 + ", " + p2 );
		Link r = new Link("secondObjectOf", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
end

/**
* this rule is not necessary, because NP_ModifiedBy_VP does the same thing.
rule "NP_VPP"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", tense=="past", graph.containLink("secondObjectOf", null, head)!=null, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		r : Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VPP: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, r, 2);// result is VP
 		insert(ph);
		ut.printPhrase(ph);
end
*/

rule "VP_VP_attachToAgent"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, subject != null)
		p2: Phrase(synType=="VP", graph.containLink("agentOfProc", null, head)==null, tense=="ing", begToken==p1.endToken)
		exists Link(type=="agentOfProc", p1.subject.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find VP_VP_attachToAgent: " + p1 + ", " + p2 );
		Link r = new Link("agentOfProc", p1.getSubject().getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_VP_attachToVerb"
// if cannot be attached to agent, then to verb
	salience -200
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, subject != null)
		p2: Phrase(synType=="VP", graph.containLink("agentOfProc", null, head)==null, tense=="ing", begToken==p1.endToken)
		not Link(type=="agentOfProc", p1.subject.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find VP_VP_attachToVerb: " + p1 + ", " + p2 );
		Link r = new Link("hasProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "TIMEP_define_NP_not_set"	// Defendants' February 9, 2009 letter
	salience -100	
	when
		p1: Phrase(synType=="TIMEP", !graph.containLinkExcept(head, "MonthValueOf", 2, "DateValueOf", 2, "YearValueOf", 2) )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, !isSet())
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
		(not Phrase(synType==null, begToken==p1.begToken, endToken==p2.endToken))//not already created, 
	then
		ut.print("Find TIMEP_define_NP_not_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "IntelName_IntelName"	// John D. Smith Kevin H. Spooner
	when
		p1: Phrase(synType=="NP", head.isKindOf("IntelName") )
		p2: Phrase(synType=="NP", head.isKindOf("IntelName"), begToken==p1.endToken)
	then
		ut.print("IntelName_IntelName: " + p1 + ", " + p2 );
		Phrase ph = p1.addToSet(null, p2, p1.getHead().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "NP_define_NP_not_set"	// Defendants'  letter, Rule 16 conference
	salience -100	// generic after specific
	when
//		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define hasAttribute hasMember hasValue", "2 1 1 1") )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, !isSet())
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
//		(not Phrase(synType=="NP", begToken<=p1.begToken, endToken>=p2.endToken))//not already created, 
	then
		ut.print("Find NP_define_NP_not_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_define_NP_set"
	salience -100	// generic after specific
	when
		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, isSet(), ph0 : subphrases.get(0), ph1 : subphrases.get(subphrases.size()-1))
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
		not (
			eval(ph1.getGraph().containLink("define", null, ph1.getHead()) != null) and
			eval(ph0.getGraph().containLink("define", null, ph0.getHead()) == null)
		)
		(not Phrase(synType==null, begToken==p1.begToken, endToken==p2.endToken))//not already created, 
	then
		ut.print("Find NP_define_NP_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "TIMEP_MEETING"
	when
		p1: Phrase(synType=="TIMEP", graph.topLink ==null )	// Sept. 6 meeting
		p2: Phrase(synType=="NP", head.isKindOf("Meeting"), begToken==p1.endToken, toplink2 : graph.topLink)
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		(not Phrase(synType=="NP", begToken==p1.begToken, endToken==p2.endToken))//not already created
	then
		ut.print("Find TIMEP_MEETING: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
			insert(ph);
			ut.printPhrase(ph);
end

rule "'s_toPos"
	when
		p1: Phrase(synType=="SYMBOL", text=="'");
		p2: Phrase(synType==null, text=="s"||text=='S', begToken==p1.endToken);
	then
		ut.print("Find 's_toPos: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph(new Entity("SymbolPossess", onto));
		Phrase ph = new Phrase("'s", "POS_SYMBOL", g, p1.getBegToken(), p2.getEndToken(), p1.getSentence());		
		insert(ph);
		ut.printPhrase(ph);
end
 
rule "Comma_And"
	when
		p1: Phrase(synType=="SYMBOL", text==";"|| text==",");
		p2: Phrase(synType!=null, text=="and", begToken==p1.endToken);
	then
		ut.print("Find Comma_And: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 2);		
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_'s_as_POS"	// Counterclaim Plaintiff Motorola, Inc.'s
	when
		p1: Phrase(synType=="NP", leafPhraseCount() < 8, !graph.containRelatedLinkExcept(head, "define hasAttribute hasMember", "2 1 1") )
		p2: Phrase(synType=="POS_SYMBOL", begToken==p1.endToken);
	then
		ut.print("Find NP_'s_as_POS: " + p1 + ", " + p2 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		Phrase ph = new Phrase(pl, "POS", p1.getGraph());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NPs'_as_POS"
	when
		p1: Phrase(synType=="NP", text.endsWith("s")||text.endsWith("S"), headLast(), head.isKindOf("IntelAgent"), !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p2: Phrase(synType=="SYMBOL", text=="'", begToken==p1.endToken);
	then
		ut.print("Find NPs'_as_POS: " + p1 + ", " + p2 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		Phrase ph = new Phrase(pl, "POS", p1.getGraph());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NPs_as_POS"
// this is to accommodate error. Plaintiff's motion => Plaintiffs motion
	when
		p1: Phrase(synType=="NP", text.endsWith("s")||text.endsWith("S"), headLast(), head.isKindOf("IntelAgent"), !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		not Phrase(synType=="SYMBOL", text=="'", begToken==p1.endToken);
	then
		ut.print("Find NPs_as_POS: " + p1 );
		Phrase ph = p1.clone();
		ph.setSynType("POS");
		insert(ph);
		ut.printPhrase(ph);
end

rule "POS_NP"
// possesive
	when
		p1: Phrase(synType=="POS")
		p2: Phrase(synType=="NP", begToken==p1.endToken, graph.containLink("hasOwner", head, null)==null, graph.containLink("hasDET", head, null)==null)
	then
		ut.print("Find POS_NP: " + p1  + ", " + p2 );
		Link r = new Link("hasOwner", p2.getHead(), p1.getHead());
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), r, 2);
		Phrase ph = new Phrase(pl, "NP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "PRP_NP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType=="NP"||synType=="TIMEP", begToken==p1.endToken)
	then
		ut.print("Find PRP_NP: " + p1 + ", " + p2 );
		Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "PRP_VP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType=="VP", tense=="ing", begToken==p1.endToken)
	then
		ut.print("Find PRP_VP: " + p1 + ", " + p2 );
		Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
	 	ut.printPhrase(ph);
end

rule "NP_NUMP"	// "DEPT. 206"
	when
		p1: Phrase(synType=="NP", head.isKindOf("OrgHierarchy"), graph.topLink == null)
		p2: Phrase(synType=="NUMP", text.length()<=4, head.isKindOf("NumberValue"), graph.topLink == null, begToken==p1.endToken) 
	then
		ut.print("Find NP_NUMP: " + p1 + ", " + p2 );
		Link r = new Link("numberIdentified", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
	 	ut.printPhrase(ph);
end
	
rule "NP_PRP"
	when
		p1: Phrase(synType=="NP", lk : graph.topLink, g1 : graph, lk1 : graph.containLink("hasMember", head, null), graph.prpCount <3, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, begToken==p1.endToken)
//		eval(lk2 != null && lk2.getType()=="PRPRelation" && !lk2.getArg2().isKindOf("Time"))// TIME is allowed on verb only, ie VP_PRP
		eval(lk2 != null && lk2.getType()=="PRPRelation" && g1.containLink(lk2.getArg1().getName(), p1.getHead(), null)==null)// TIME is allowed on verb only, ie VP_PRP
		(or
			(
				eval(lk1 == null) and
				exists Link(type==p2.getHead().name, p1.getHead().isKindOf(arg1), lk2.arg2.isKindOf(arg2))
			)
			(
				eval(lk1 != null) and
				exists Link(type==p2.getHead().name, lk1.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
			)
		)
//		eval(!(p1.getGraph().prpCount() > 3  && !p2.getHead().isKindOf("byAgent")))
//		not (
//		eval(lk !=null && onto.isKindOf(lk.getType(), "ugoerOfProc") && lk.getArg1().equals(p1.getHead())) and
//		exists Link(type==p2.head.name, lk.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
//		)
 	then
		ut.print("Find NP_PRP: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end

rule "NP_PRP_and_PRP"
	when
		p1: Phrase(synType=="NP", lk : graph.topLink, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, begToken==p0.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && !lk2.getArg2().isKindOf("Time"))// TIME is allowed on verb only, ie VP_PRP
		exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
 	then
		ut.print("Find NP_PRP: " + p1 + ", " + p0 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end


rule "NP_PRP_VP_ATTACH" // Case associated with lead case.
	when
		p1: Phrase(synType=="NP", lk : graph.containLink("ugoerOfProc", head, null), lk != null, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, lk2 !=null, begToken==p1.endToken)
		not ( exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))) // cannot attach to NP. If it can, NP_PRP will fire
		exists Link(type==p2.head.name, lk.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))	// can attach to Verb
 	then
		ut.print("Find NP_PRP_VP_ATTACH: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk.getArg2(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end

rule "NP_PRP_VP_ATTACH_and_PRP"
	when
		p1: Phrase(synType=="NP", lk : graph.containLink("ugoerOfProc", head, null), lk != null, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, lk2 !=null, begToken==p0.endToken)
		not ( exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))) // cannot attach to NP. If it can, NP_PRP will fire
		exists Link(type==p2.head.name, lk.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))	// can attach to Verb
 	then
		ut.print("Find NP_PRP_VP_ATTACH: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk.getArg2(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end


rule "NP_PRP_of"	// day 9 of trial (graph.containLink("hasValue", head, null))
	when
	   p1: Phrase(synType=="NP", lk : graph.topLink, headLast()||graph.containLink("hasValue", head, null) != null, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		(or 
			eval(lk==null) 
			eval(lk !=null && (!(onto.isKindOf(lk.getType(), "ugoerOfProc") && lk.getArg1().equals(p1.getHead()))))
		)
		p2: Phrase(synType=="PRP", head.isKindOf("of"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
 	then
		ut.print("Find NP_PRP_of: " + p1 + ", " + p2 );
		Entity head = p1.getHead();
		Link r = null;
		int headAt = 1;
		Phrase ph;
		if(head.isKindOf("Measure")){
				r = new Link("hasMeasure", lk2.getArg2(), head);
			ph = new Phrase(p1, p2, r, 2);
			ph.getGraph().remove(p2.getHead());
			ph.getGraph().setHead(lk2.getArg2());
			ph.setSynType("NP");
		}
		else{
				r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
			ph = new Phrase(p1, p2, r, 1);
			ph.getGraph().remove(p2.getHead());
		}
			insert(ph);
	 	ut.printPhrase(ph);
end
rule "QUANTIFIER_PRP"
// some of the books
	when
		p1: Phrase(synType=="QUANTIFIER")
		p2: Phrase(synType=="PRP", head.isKindOf("of"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && !lk2.getArg2().isKindOf("Time"))
	then
		ut.print("Find QUANTIFIER_PRP: " + p1 + ", " + p2 );
		Entity ehead = lk2.getArg2();
		Link r = new Link("hasAttribute", ehead, p1.getHead());
		ERGraph g = p2.getGraph();
		Entity oldHead = p2.getHead();
		g.setHead(ehead);
		Phrase ph = new Phrase(p1, p2, r, 2);
		g = ph.getGraph();
		g.remove(oldHead);
		insert(ph);
		ut.printPhrase(ph);
end



rule "PRP_or_PRP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null, begToken==p2.endToken)
	then
		ut.print("Find PRP_PRP: " + p1 + ", " + p2+ ", " + p3 );
		Phrase ph = p1.addToSet(p2, p3, "PRPRelation", true);
		if(ph != null){
			insert(ph);
		}
	 	ut.printPhrase(ph);
end


rule "VP_PRP_to_V"	// filed, by Alphapharm Pty Ltd., Mylan Pharmaceuticals Inc.
	when
		p1: Phrase(synType=="VP", g1 : graph, lk1 : graph.containLink("ugoerOfProc", null, head))
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		not (
				eval(g1.containLink("agentOfProc", null, p1.getHead())!=null) and
				eval(p2.getHead().getName().equals("byAgent"))
			)
			not (
				eval(lk1 != null) and
			exists Link(type==p2.head.name, lk1.arg1.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		)
 	then
		ut.print("Find VP_PRP_to_V: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end

rule "VP_PRP_to_UGOER" //Complaint filed with Jury Demand against Amazon.com Inc.
	when//(390:InPersonSchedulingConference) ugoerOfProc (385:ProcSet) ==> topLink
		p1: Phrase(synType=="VP", g1 : graph, lk1 : graph.containLink("ugoerOfProc", null, head), lk1 != null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isInstanceOf("re"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		exists Link(type==p2.head.name, lk1.arg1.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
 	then
		ut.print("Find VP_PRP_to_UGOER: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk1.getArg1(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end


rule "VP_PRP_and_PRP" //Summons Reissued as to Fandango Inc. c/o CT Corp. and at Los Angeles, CA address
	when
		p1: Phrase(synType=="VP", g1 : graph, graph.topLink != null && onto.isKindOf(graph.topLink.getType(), "PRPRelation") )
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), lk2: graph.topLink, begToken==p0.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		not (
				eval(g1.containLink("agentOfProc", null, p1.getHead())!=null) and
				eval(p2.getHead().getName().equals("byAgent"))
			)
 	then
		ut.print("Find VP_PRP: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
	 	ut.printPhrase(ph);
end

rule "ADJP_NP"
	when
		p1: Phrase(synType=="ADJP" ||synType=="QUANTIFIER"  )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink)
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") ))
	then
		ut.print("Find ADJP_NP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

/** limited use for not important DE, summons issued etc.

rule "parallel_3_phrase"
	salience -1000
	when
		p1: Phrase(synType!=null);
		p2: Phrase(synType=="SYMBOL", head.name=="SymbolSemicolon", begToken==p1.endToken)
		p3: Phrase(synType!=null, begToken==p2.endToken)
		p4: Phrase(synType!=null, begToken==p3.endToken)
		p5: Phrase(synType!=null, begToken==p4.endToken)
		p6: Phrase(synType=="SYMBOL", head.name=="SymbolSemicolon"||head.name=="SymbolDot", begToken==p5.endToken)
		not Phrase(subphrases != null, subphrases.contains(p1))
		not Phrase(begToken <= p3.begToken, endToken >= p5.endToken)
		eval(p1.lastPhrases(p3, p4, p5) != null)
	then
		List<Phrase> list = p1.lastPhrases(p3, p4, p5);
		int index = list.get(0).getBegToken();
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p3);
		pl.add(p4);
		pl.add(p5);
		List<Phrase> px = p1.joinParse(index, pl);
		ut.print("Find parallel_3_phrase for:  " + p1 +", "+ p2 +", "+p3 +", "+p4 +", "+p5 +", " +p6 + "\n\n");
		if(px != null){
			Phrase ph = new Phrase(p1, px.get(0), (Link)null, 0);
			ph.setComposite(true);
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

/* Too costly and having trouble handle unexpected. Like 

99565	1:09-cv-00651-LPS
serial: 104
	D.I. 70	
NOTICE OF SERVICE of BRISTOL-MYERS SQUIBB CO. AND BRISTOL-MYERS SQUIBB PHARMA CO.S RESPONSES AND OBJECTIONS TO DEFENDANTS FIRST SET OF INTERROGATORIES TO PLAINTIFFS and BRISTOL-MYERS SQUIBB CO. AND BRISTOL-MYERS SQUIBB PHARMA CO.S RESPONSES AND OBJECTIONS TO DEFENDANTS FIRST REQUEST FOR PRODUCTION OF DOCUMENTS AND THINGS TO PLAINTIFFS by Bristol-Myers Squibb Co., Bristol-Myers Squibb Pharma Co., Merck & Co., Inc., Merck Sharp & Dohme Corp..(Stover, Chad) (Entered: 08/16/2010)


rule "and_phrases"
	salience -1000
	when
		p1: Phrase(synType!=null && synType!="EMPTY" );
		p2: Phrase(begToken==p1.begToken, endToken > p1.endToken)
		p3: Phrase(synType!=null, text.equalsIgnoreCase("and"), begToken==p2.endToken)
		p4: Phrase(synType!=null, begToken==p3.endToken)
		not Phrase(begToken <= p1.begToken, endToken >= p4.endToken)
	then
		List<Phrase> px = p1.joinParse(p4);
		ut.print("Find and_phrases for:  " + p1 +", "+ p2 +", "+p3 +", "+p4 + "\n\n");
		if(px != null ){
			Phrase ph = new Phrase(p1, px.get(0), (Link)null, 0);
			ph.setComposite(true);
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

rule "find top phrases"
	salience -10010
	when
		p1: Phrase(synType != null, synType != "SYMBOL")
		(not Phrase(subphrases != null, subphrases.contains(p1)))
//		(not Phrase(begToken <= p1.getBegToken(), endToken >= p1.getEndToken(), (endToken - begToken) > (p1.getEndToken() - p1.getBegToken())))
		(not Phrase(
			(begToken < p1.getBegToken() && endToken >= p1.getEndToken())
			||
			(begToken <= p1.getBegToken() && endToken > p1.getEndToken())
			)
		)
	then
		ut.print("Top phrase:  " + p1);
		ut.print(p1.getBegToken() + ", " + p1.getEndToken());
//			ut.printPhrase(p1);
//		ut.print(p1.getGraph().toGraph());
end


rule "Collection_OR"//"answer/response"
	salience 100
	when
		lk: Link(arg2.name=="CollectionClass", type=="subclassOf");
		p1: Phrase(synType!=null&&synType!="VP", graph.topLink == null, head.isKindOf(lk.getArg1())); 
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType!=null&&synType!="VP", synType==p1.getSynType(), begToken==p2.endToken, graph.topLink == null, head.isKindOf(lk.getArg1()))
		not( exists (Link(this != lk, arg2.name=="CollectionClass", type=="subclassOf", arg1.isKindOf(lk.arg1), p1.head.isKindOf(arg1), p2.head.isKindOf(arg1))))
	then
		ut.print("Find collection_OR for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, lk.getArg1().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end



rule "VP_collection"
	salience 100
	when
		p1: Phrase(synType=="VP", graph.topLink == null);
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType=="VP", tense==p1.getTense(), graph.topLink == null, begToken==p2.endToken)
	then
		ut.print("Find VP_collection for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, p1.getHead().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "Collection_Range" //"07-2017"
	salience 100
	when
		p1: Phrase(synType!=null, graph.topLink == null, head.isKindOf("EntityValue"));
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolHyphen"), begToken==p1.endToken)
		p3: Phrase(synType!=null, p1.synType==synType, graph.topLink == null, head.isKindOf("EntityValue"), begToken==p2.endToken)
	then
		ut.print("Find Collection_Range for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, p1.getHead().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end


rule "combine_identical_phrases"
	salience 1001
	when
		p1: Phrase(synType != null); 
		p2: Phrase(synType != null, begToken==p1.begToken, endToken==p1.endToken)
		eval(p1 != p2 && p1.equivalent(p2))
	then
		ut.print("combine_identical_phrases, removing: " + p2);
		retract(p2);
end

rule "AppearanceOfAttorney_infer_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
 //	   eval(lastph!= null ("Attorney"))
 		p3: Phrase(synType != null, begToken > p1.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
 		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2) 
 		not Phrase(synType != null, begToken < p3.begToken, endToken > p3.begToken)
 		not Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
				eIndex --;
				etk = tks.get(eIndex);
			}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
//		System.err.println("identify attorney name: " + namepart);
		List<String> names = EntType.BreakNames(namepart);
		for(String name : names){
			onto.createNewPerson(name, "Attorney", onto, drools.getWorkingMemory());
//			System.err.println(name);
		}
end

rule "AppearanceOfAttorney_infer_name_2"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lk : graph.topLink, graph.topLink != null)
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
		p2: Phrase(synType!=null, text==";"|| text==","|| head.isKindOf("ConjAnd"), begToken==p1.endToken)
 		p3: Phrase(synType != null, begToken > p2.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
 		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_2: " + p1 + ", " + p2 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		// check junk got suspected as name parts:
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("esq") || txt.equals("filed") || txt.equals("by")||txt.equals("esquire")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String namepart = sent.substring(btk.getStart(), etk.getStart());
			onto.createNewPerson(namepart, "Attorney", onto, drools.getWorkingMemory());
		}
end

rule "AppearanceOfAttorney_infer_name_3"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
 //	   eval(lastph!= null ("Attorney"))
 		p3: Phrase(synType != null, text.equalsIgnoreCase("of"), begToken > p1.endToken + 1)
 		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
 		not Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_3: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
			eIndex --;
			etk = tks.get(eIndex);
		}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "Attorney", onto, drools.getWorkingMemory());
end

rule "AppearanceOfAttorney_infer_lawfirm_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
		p2: Phrase(synType == "NP", head.isKindOf("Human"));
 		p3: Phrase(synType != null, text.equalsIgnoreCase("of"), begToken == p2.endToken)
 		p4: Phrase(synType != null, begToken > p3.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
 		not Phrase(synType != null, begToken >= p3.endToken, endToken <= p4.begToken, endToken - begToken >= 2)
 		not Phrase(synType != null, text.equalsIgnoreCase("of"), begToken >= p3.endToken, endToken <= p4.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_lawfirm_name_1: " + p1 + ";; " + p2 + ";; " + p3 + ";; " + p4);
		List<LexToken> tks = p1.getSentence();
		int bIndex = p3.getEndToken();
		int eIndex = p4.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
			eIndex --;
			etk = tks.get(eIndex);
		}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "Lawfirm", onto, drools.getWorkingMemory());
end

rule "DepositionDeclarationReportOfPeople_infer_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("Deposition")||head.isInstanceOf("DocLegalDeclaration")||head.isInstanceOf("DocLegalReport"), headLast());
		p2: Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken==p1.endToken);
		(or
			p3: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), begToken > p2.endToken + 1,  endToken - begToken >= 2)
			p3: Phrase(synType=="SYMBOL", text=="("||text=="]", begToken > p2.endToken + 1) 
		)
 		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
 		not Phrase(synType =="SYMBOL",begToken >= p2.endToken, endToken <= p3.begToken, text=="("||text=="]"||text==";")
	then
		ut.print("Find DepositionDeclarationReportOfPeople_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("esq") || txt.equals("filed") || txt.equals("by")||txt.equals("esquire")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String namepart = sent.substring(btk.getStart(), etk.getStart());
			String nl = namepart.toLowerCase();
			if(!(nl.contains("plaintiff") ||nl.contains("defendant") ||nl.contains("mailing"))){
				onto.createNewPerson(namepart, "OtherPerson", onto, drools.getWorkingMemory());
			}
		}
end

rule "CorporateParent_infer_name_1" //Corporate Parent Shionogi & Co. Ltd. for Sciele Pharma Inc.
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("CorporateParent"), headLast());
		p3: Phrase(synType=="PRP", head.isKindOf("for"), begToken > p1.endToken + 1,  endToken - begToken >= 2)
 		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find CorporateParent_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "OrgCo", onto, drools.getWorkingMemory());
end

rule "Judge_infer_name_1" //Case assigned to Judge Joseph J. Farnan, Jr. Please include the initials
	salience -2000
	when
		p1: Phrase(synType == "NP", text.equalsIgnoreCase("Judge"));
		p2: Phrase(text.length > 1, begToken > p1.endToken, begToken - p1.endToken < 7);	// avoid the dot after initial, like "J."
//		(or
//			p3: Phrase(synType=="VP", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
//			p3: Phrase(synType=="PRP", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
			p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
//		)
 		not Phrase(synType == "VP"||synType == "PRP", begToken >= p1.endToken, endToken <= p2.begToken)
		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
 	then
		ut.print("Find Judge_infer_name_1: " + p1 + ";; " + p2 + ";; " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p2.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
 		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
//		ut.print("name: " + namepart);
		onto.createNewPerson(namepart, "Judge", onto, drools.getWorkingMemory());
end


rule "IssueSubpoena_infer_name_1"
	salience -1020
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcIssueDoc")||head.isInstanceOf("ProcServeDoc"), lk : graph.topLink, lk != null, lk.arg1==head, lk.arg2.isInstanceOf("DocLegalSubpoena"));
		p2: Phrase(synType == "PRP", text.equalsIgnoreCase("on")||text.equalsIgnoreCase("upon"), begToken==p1.endToken);
		p3: Phrase(synType=="PRP", head.isInstanceOf("byAgent"), begToken > p2.endToken + 1,  endToken - begToken >= 2)
		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find IssueSubpoena_infer_name_1: " + p1 + ", " + p2  + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		if(EntType.isOrgCo(namepart)){
			onto.createNewPerson(namepart, "OrgCo", onto, drools.getWorkingMemory());
		} else {
			onto.createNewPerson(namepart, "OtherPerson", onto, drools.getWorkingMemory());
		}
end


rule "DET_NP"
	when
		p1: Phrase(synType == "DET");
		p2: Phrase(synType == "NP", begToken==p1.endToken,graph.containLink("hasDET", head, null) ==null)
	then
		ut.print("Find DET_NP: " + p1 + ", " + p2 );
		Link r = new Link("hasDET", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NumberClass_NumberValue"	// Number 788,200
	when
		p1: Phrase(synType == "NP", head.isKindOf("NumberClass"));
		p2: Phrase(synType == "NUMP", begToken==p1.endToken)
	then
		ut.print("Find NumberClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "MoneySymbol_MoneyValue"	// $ 455.00
	when
		p1: Phrase(synType == "SYMBOL", head.isInstanceOf("SymbolDollar"));
		p2: Phrase(synType == "NUMP", begToken==p1.endToken)
	then
		ut.print("Find MoneySymbol_MoneyValue: " + p1 + ", " + p2 );
		int tkpos = p1.getBegToken();
		List<LexToken> tks = p1.getSentence();
		LexToken bk = tks.get(tkpos);
		int offset = bk.getStart();
		String sent = bk.parent;
		int endT = p2.getEndToken();
		LexToken ek = tks.get(endT-1);
		int endOffset = ek.getEnd();
		String txt = sent.substring(offset, endOffset);
	 	ERGraph g = new ERGraph(new Entity(txt, onto.getEntity("MoneyValue"), Entity.TYPE_INSTANCE, onto, p1.getBegToken()));
		Phrase ph = new Phrase(txt, "NP", g, p1.getBegToken(), p2.getEndToken(), tks);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "SerialClass_NumberValue"	// Number 788,200, Rule 16.2b Scheduling Teleconference
	when
		p1: Phrase(synType == "NP", head.isKindOf("SerialClass"), graph.links==null);
		p2: Phrase(synType == "NUMP"||synType == "LETT", begToken==p1.endToken)
	then
		ut.print("Find SerialClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);	
		r = new Link("define", p1.getHead(), p2.getHead());
		ph = new Phrase(p1, p2, r, 2);
		ph.setSynType("NUMREF");
		insert(ph);
		ut.printPhrase(ph);	
end


rule "NumberedClass_NumberClass"
	when
		p1: Phrase(synType == "NP", head.isKindOf("NumberedClass"));
		p2: Phrase(synType == "NP", head.isKindOf("NumberClass"), graph.containLink("hasValue", head, null)!=null, begToken==p1.endToken)
	then
		ut.print("Find NumberedClass_NumberClass: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "Order_that"
	when
//		p1: Phrase(synType == "NP", head.isKindOf("DocLegalOrder"), graph.links==null);
		p1: Phrase(synType == "NP", head.isKindOf("Document"), graph.links==null);
		p2: Phrase(synType == "DET", text.equalsIgnoreCase("that"), begToken==p1.endToken)
		p3: Phrase(synType == "VP", graph.links != null, graph.links.size()>3, begToken==p2.endToken)
	then
		ut.print("Find Order_that: " + p1 + ", " + p2 + ", " + p3 );
		Link r = new Link("hasContent", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p2, p3, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "re_NUMREF"
	when
		p1: Phrase(synType == "PRP", head.isInstanceOf("re"), graph.topLink==null);
		p2: Phrase((synType=="NUMP" && text.length()<=4) || synType=="NUMREF", head.isKindOf("NumberValue"), begToken == p1.endToken) 
	then
		ut.print("Find re_NUMREF: " + p1 + ", " + p2 );
	   Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
 		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

// spaces between result in case number having detached parts, just throw them away.
rule "CaseNumber_leftover"	// (65 in 1:09-cv-00131-SLR -MPT, 72 in 1:09-cv-00130-SLR -MPT)
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("CaseNumber"), graph.containLink("hasMember", head, null)==null);
		p2: Phrase(text=="-", begToken == p1.endToken) 
		p3: Phrase(text.length()<=4, text.length() >=2, begToken == p2.endToken) 
	then
		ut.print("Find CaseNumber_leftover: " + p1 + ", " + p2 + ", " + p3 );
		Phrase ph = new Phrase(p1.getText() + p2.getText() + p3.getText(), p1.getSynType(), p1.getGraph(), p1.getBegToken(), p3.getEndToken(), p1.getSentence());
		insert(ph);
	 	ut.printPhrase(p1);
end

rule "Person_Suffix"
	salience -200
	when
		p1: Phrase(synType == "NP", head.isKindOf("Human"))
		p2: Phrase(synType == "PERSONSUFFIX", begToken==p1.endToken)
//		not Phrase(synType=="NP", begToken<=p1.begToken, endToken>=p2.endToken)
// the following cause infinite loop for case 2000005108 serail 41:
		not Phrase(synType=="NP", head.isKindOf("Human"), begToken<=p1.begToken, endToken>=p2.endToken)
	then
		ut.print("Find Person_Suffix: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Document_due_date"	// answer due 5/10/2011
	when
		p1: Phrase(synType=="NP", head.isKindOf("Document"))
		p2: Phrase(synType !=null, text.equalsIgnoreCase("due"), begToken==p1.endToken)
		(or
			p3: Phrase(synType=="TIMEP", dat : head, head.isInstanceOf("DateValue"), begToken==p2.endToken)
				p3: Phrase(synType=="PRP", lk : graph.topLink , lk!= null, lk.type=="PRPRelation", lk.arg1.isKindOf("byAgent") || lk.arg1.isKindOf("on")  , dat : graph.topLink.arg2, begToken==p2.endToken)
		)	  
	then
		ut.print("Find document_due_date: " + p1 + ", " + p2 + ", " + p3);
//		Link r = new Link("hasDueDate", p1.getHead(), p3.getHead());
		Link r = new Link("hasDueDate", p1.getHead(), dat);
		Phrase ph = new Phrase(p1, p2, p3, r, 1);
		if(p3.getSynType().equals("PRP")){
				ph.getGraph().remove(p3.getHead());
		}
			insert(ph);
			ut.printPhrase(ph);
end

/**
// this is too ambitious, gets too complicated
rule "Collection_2" //"trial, JURY TRIAL", 
	salience 100
	when
		p1: Phrase(synType!=null, g1 : graph); //graph.isSet() == false, 
		p2: Phrase(synType != null, st: synType, head.name != null, nm : head.name, begToken==p1.endToken)
		eval( !g1.containLinkKind("ugoerOfProc", p1.getHead(), (Entity)null) && !g1.containLinkKind("ToInfinitive", p1.getHead(), (Entity)null))
		(or
			eval(st.equals("SYMBOL") && (nm.equals("SymbolComma") || nm.equals("SymbolSemicolon")))
			eval(st.equals("CONJ") && nm.equals("ConjAnd"))
		)
		p3: Phrase(synType!=null, p1.synType == synType, head.isKindOf(p1.head), begToken==p2.endToken, g3 : graph)
		eval( !g3.isSet() && !g3.containLinkKind("ToInfinitive", p3.getHead(), (Entity)null))
		eval(p1.topLinkMatch(p3))
		eval(p3.leafPhraseCount() < 10)
		eval(p1.hasAttribute("NumberValue") == p3.hasAttribute("NumberValue"))
		(or
			eval(p1.leafPhraseCount() < 10)
			eval(p1.isSet())
		)
		not Phrase(synType != null, begToken <= p1.begToken, endToken >= p3.endToken, head.isKindOf(p1.head) || p1.head.isKindOf(head))
	then
		ut.print("Find collection_2 for:  " + p1 +", "+ p2 +", "+p3 );
			Phrase ph = p1.addToSet(p2, p3, p1.getHead().getName(), true);
			if(ph != null){
				insert(ph);
					ut.printPhrase(ph);
			}
//		}
end
*/
/**
rule "Collection_3"//"complaint , PROOF OF SERVICE"
	salience 100
	when
		lk: Link(arg2.name=="CollectionClass", type=="subclassOf")
		p1: Phrase(synType!=null, gg1 : graph, hd1 : head); //graph.isSet() == false, 
		eval(hd1.isKindOf(lk.getArg1()))
		eval(!gg1.containLinkKind("ugoerOfProc", hd1, (Entity)null) && !gg1.containLinkKind("ToInfinitive", hd1, (Entity)null))
		 
		p2: Phrase(synType!=null, text==";"|| text==","|| head.isKindOf("ConjAnd"), begToken==p1.endToken)
		p3: Phrase(synType!=null, p1.synType == synType, begToken==p2.endToken, gg3 : graph, hd3 : head) // this is taken care of by Collection_2
		eval (!hd3.isKindOf(hd1) && hd3.isKindOf(lk.getArg1()))
		not Link(arg2.name=="CollectionClass", type=="subclassOf", 
					arg1.isKindOf(lk.arg1) && ( !arg1.equals(lk.arg1)),
					hd1.isKindOf(arg1),
					hd3.isKindOf(arg1)
				) 		
		eval(!gg3.containLinkKind("ugoerOfProc", p3.getHead(), (Entity)null) && !gg3.containLinkKind("ToInfinitive", p3.getHead(), (Entity)null))
		(or
			eval(!p1.getGraph().containLinkKind("PRPRelation", p1.getHead(), (Entity)null))
			eval(p1.getGraph().containLink("with", p1.getHead(), null) != null) // let "with" be an exception
		)
		(or
			eval(!p3.getGraph().containLinkKind("PRPRelation", p3.getHead(), (Entity)null))
			eval(p3.getGraph().containLink("with", p3.getHead(), (Entity)null) != null) // let "with" be an exception
		)
		not (	// no closer common ancester exists:
			lk2: Link(arg2.name=="CollectionClass", type=="subclassOf") and
			eval(!lk2.equals(lk)) and
			eval(p1.getHead().isKindOf(lk2.getArg1()) && p3.getHead().isKindOf(lk2.getArg1()) ) and
			eval(lk2.getArg1().isKindOf(lk.getArg1()))
		)
		not (	// no even longer phrase exists:
		  Phrase(synType!=null, p1.synType == synType, begToken==p2.endToken, endToken > p3.endToken, gg4 : graph, hd4 : head) and
		  eval(!hd4.isKindOf(hd1) && hd4.isKindOf(lk.getArg1())) and
		  eval( !gg4.containLinkKind("PRPRelation", hd4, (Entity)null) && !gg4.containLinkKind("ugoerOfProc", hd4, (Entity)null) && !gg4.containLinkKind("ToInfinitive", hd4, (Entity)null))
		)
		not Phrase(synType!=null, isSet(), p1.head.isKindOf(head), begToken < p1.begToken, endToken >= p1.endToken)
		eval(p1.leafPhraseCount() < 10)
		(or
			eval(p3.leafPhraseCount() < 10)
			eval(p3.isSet())
		)
		eval(p1.hasAttribute("NumberValue") == p3.hasAttribute("NumberValue"))
	then
		ut.print("Find collection_3 for:  " + p1 +", "+ p2 +", "+p3 );
//		boolean b1 = p1.hasAttribute("NumberValue");
//		boolean b2 = p3.hasAttribute("NumberValue");
//		System.out.println("b1:" + b1 + ", " + "b2: " + b2);
		ERGraph g1 = p1.getGraph();
		ERGraph g2 = p3.getGraph();
		if(g1.topLinkMatch(g2)){
			Phrase ph = p3.addToSet(p2, p1, lk.getArg1().getName(), false);
			if(ph != null){
				insert(ph);
				ut.printPhrase(ph);
			}
		}
end
*/

rule "Number_Document"	// re 23 motion
	when
		p1: Phrase((synType=="NUMP" && text.length()<=4) || synType=="NUMREF", head.isKindOf("NumberValue")) 
//		p2: Phrase(synType=="NP", head.isKindOf("Document"), g: graph,  graph.containLink("hasMember", head, null)==null, begToken==p1.endToken)
		p2: Phrase(synType=="NP", head.isKindOf("Document"), g: graph,  begToken==p1.endToken)
		eval( !g.containLinkKind("PRPRelation", p2.getHead(), (Entity)null) && !g.containLinkKind("ToInfinitive", p2.getHead(), (Entity)null))
//			!graph.containLinkKind("ugoerOfProc", head, (Entity)null),
//			!graph.containLinkKind("PRPRelation", head, (Entity)null),
//			!graph.containLinkKind("ToInfinitive", head, (Entity)null), begToken==p1.endToken
//		)
	then
		ut.print("Find Number_Document: " + p1 + ", " + p2 );
		Entity hd = p2.getHead();
		boolean bNum = false;
		List<Link> lks = g.containLinkList("hasMember", hd, null);
		if(lks != null){
			for(Link lk : lks){
				Entity e2 = lk.getArg2();
				List<Entity> le = g.getModifierList(e2);
				if(le != null){
					for(Entity e : le){
						if(e.isInstanceOf("NumberValue")){
							bNum = true;
							break;
						}
					}
				}
				if(bNum){
					break;
				}
			}
		}
		if(!bNum){
			Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
			Phrase ph = new Phrase(p1, p2, r, 2);
			insert(ph);
			ut.printPhrase(ph);
		}
end


rule "Document_Number"	// re 23 motion
	when
		p1: Phrase(synType=="NP", head.isKindOf("DocLegalMotion"), g: graph)
		p2: Phrase(synType=="NUMREF", head.isKindOf("NumberValue"),  graph.containLinkKind("define", onto.getEntity("DocketEntryIndex"), head) != null, begToken==p1.endToken) 
//		eval( !g.containLinkKind("PRPRelation", p1.getHead(), (Entity)null) && !g.containLinkKind("ToInfinitive", p1.getHead(), (Entity)null))
	then
		ut.print("Find Document_Number: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule		"remove all phrases"
	salience 10000
	when
		LexFlag(flag==true)
		ph :Phrase()
	then
//	System.out.println("remove phrase: " + ph);
		retract(ph);
end

rule	"count phrases"
	salience 10000
	when
		pc :PhraseCounter()
		ph :Phrase(synType !=null)
	then
		int cnt = pc.incrementPhraseCount();
//		if(cnt % 100 == 0){
//			System.err.println("\nPhraseCount: " + cnt);
			if(cnt >= 5000){
				drools.halt();
			}
//		}
end


rule		"remove LexFlag"
	salience 10000
	when
		lf: LexFlag()
		pc: PhraseCounter()
		not Phrase()
	then
//	System.out.println("remove LexFlag");
//		int cnt = pc.getPhraseCount();
//		System.err.println("Phrase count: " + cnt);
//		ut.print("Phrase count: " + cnt);
		retract(lf);
		retract(pc);
end

/**
The following rule can cause problems.
	The rule, Person_Suffix, has a not condition. 
	the first time Person_Suffix fires, it'll generate a new phrase. This new phrase inhibits Person_Suffix from
	firing again through the NOT condition. But if the following "remove more phrase" removes the newly generated
	phrase, Person_Suffix will keep on firing, because, every time removal of the newly created phrase validates
	the NOT condition again, the Person_Suffix rule gets activated. It should not be that way, but it is, at least
	for Drools version 5.5.0 final. I changed Person_Suffix rule to avoid the infinite loop for case 2000005108 serial 41.
	WILLIAM J. O'SHAUGHNESSY, ESQ is in the Attorney field and in the Party field, which Created OrgCoWILLIAMJOSHAUGHNESSYESQ
	with text "WILLIAM J. O'SHAUGHNESSY, ESQ" that compete successfully with "WILLIAM J. O'SHAUGHNESSY", because the
	former is longer.
*/
rule "remove more phrase"
	salience 10000
	when
		p1 : Phrase(synType != null )
		p2 : Phrase(synType == p1.synType, p1.head.isKindOf(p2.head) || p2.head.isKindOf(p1.head), begToken == p1.begToken, endToken == p1.endToken, entityCount < p1.entityCount)
	then
		ut.print("remove more phrase: " + p1 + "::" + p1.getEntityCount() + " <==> " + p2 + "::" + p2.getEntityCount());
		retract(p1);
end



query "One Phrase longest sentence"
//	ph : Phrase(begToken ==0, synType != null)
	ph : Phrase(begToken ==0, synType != null, synType != "EMPTY")
	(not Phrase(subphrases != null, subphrases.contains(ph)))
	(not Phrase(begToken == 0, endToken > ph.endToken))
end




query "all phrases"
	ph : Phrase(synType != null, synType != "SYMBOL", synType != "EMPTY")
end
