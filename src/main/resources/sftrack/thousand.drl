//created on: Jul 11, 2013
package sftrack;

import java.util.ArrayList;
import java.util.List;
import sftrack.CaseData.LitiParty;
import sftrack.Ontology;
//declare any global variables here
global LtUtil ut;
global Ontology onto;

rule "dicklook"
	when
		p1: Phrase(synType==null)
		p2: DictPhrase(match(p1) !=null)
	then
		ut.print("Find dicklook: " + p1);
		Phrase ph = p2.match(p1);
		ut.printPhrase(ph);
		insert(ph);
end

rule "dicklook_rescue"	
	salience -3000
	// for Amazon.com, Inc., sometimes only "Amazon" appear in the text.
	when
		p1: Phrase(synType==null)
		p2: DictPhrase(matchFirstOne(p1) !=null)
		not Phrase(synType != null, begToken<=p1.begToken, endToken >= p1.endToken)
	then
		ut.print("Find dicklook_rescue: " + p1);
		Phrase ph = p2.matchFirstOne(p1);
		ut.printPhrase(ph);
		insert(ph);
end

rule "number_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_NUMBER)
	then
		ut.print("Find number_1: " + p);
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "letter_1"	// Single letters, like A, B, .... in "Exhibit A and B"
	when
		p: Phrase(synType==null, text.length()==1, sentence.get(begToken).type == LexToken.LEX_WORD)
	then
		ut.print("Find letter_1: " + p);
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "LETT", g);
		insert(ph);
		ut.printPhrase(ph);
end



rule "date_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_DATE)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("DateValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "casenumber_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_FED_CASENUMBER)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("CaseNumber"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Number_In_CaseNumber"	// 330 in 1:11-cv-00315-SLR
	when
		p1: Phrase(synType=="NUMP", head.isKindOf("NumberValue"), text.length() <= 4) 
		p2: Phrase(synType=="PRP", head.isKindOf("in"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && lk2.getArg2().isInstanceOf("CaseNumber"))
	then
		ut.print("Find Number_In_CaseNumber: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		ph.setSynType("NUMREF");
		insert(ph);
		ut.printPhrase(ph);
end

rule "Number_In_CaseNumber_in_braces"	// (330 in 1:11-cv-00315-SLR)
	when
		p1: Phrase(synType=="SYMBOL", text=="(") 
		p2: Phrase(synType=="NUMREF", begToken==p1.endToken) 
		p3: Phrase(synType=="SYMBOL", text==")", begToken==p2.endToken)
	then
		ut.print("Find Number_In_CaseNumber_in_braces: " + p1 + ", " + p2 + ", " + p3 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);		
		Phrase ph = new Phrase(pl, "NUMREF", p2.getGraph());
			insert(ph);
		ut.printPhrase(ph);
end


rule "time_1"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_TIME)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("MinuteValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "number_2"
	when
		p: Phrase(synType==null, sentence.get(begToken).type == LexToken.LEX_DIGIT)
	then
		ERGraph g = new ERGraph(new Entity(p.getText(), onto.getEntity("NumberValue"), Entity.TYPE_INSTANCE, onto, p.getBegToken()));
		Phrase ph = new Phrase(p, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_name"	// July 4, 2013
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
		p3: Phrase(synType=="SYMBOL", text==",", begToken==p2.endToken)
		p4: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4, begToken==p3.endToken)
	then
		ut.print("Find month_date_year: " + p1 + ", " + p2 + ", " + p3 + ", " + p4);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		int monthnum = LtUtil.getMonthNumber(p1.getHead().getTheClass().getName());
		Entity e1 = new Entity(""+ monthnum, onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p4.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p4.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, p3, p4, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "DateValue_MinuteValue"	// Conference set for 1/5/2010 01:00 PM
	when
		p1: Phrase(synType=="TIMEP", g1 : graph, graph.topLink==null, head.isKindOf("DateValue"))
		p2: Phrase(synType=="TIMEP", g2 : graph, graph.topLink==null, head.isKindOf("MinuteValue"), begToken==p1.endToken)
	then
		ut.print("Find DateValue_MinuteValue: " + p1 + ", " + p2);
		Entity e0 = new Entity("TimeValue", onto);
		ERGraph g = new ERGraph(e0);
		g.merge(g1);
		g.merge(g2);
		Link lk = new Link("MinuteValueOf", e0, p2.getHead());
		g.addLink(lk);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_slash"	// 07/04/2013
	when
		p1: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2)
		ps1: Phrase(synType=="SYMBOL", text=="/"||text=="-", begToken==p1.endToken)
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==ps1.endToken)
		ps2: Phrase(synType=="SYMBOL", text=="/"||text=="-", begToken==p2.endToken)
		p3: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4||graph.head.name.length ==2, begToken==ps2.endToken)
	then
		ut.print("Find month_date_year_slash: " + p1 + ps1 + p2 + ps2 + p3);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = new Entity(p1.getText(), onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p3.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p3.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(ps1);
		pl.add(p2);
		pl.add(ps2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date_year_space"	//Official Transcript of Trial Day 4 held on 10 14 11 before Judge Sleet.
	when
		p1: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2)
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
		p3: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==2 || graph.head.name.length ==4 , begToken==p2.endToken)
	then
		ut.print("Find month_date_year_space: " + p1 + ", " + p2 + ", " + p3);
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = new Entity(p1.getText(), onto.getEntity("MonthNumber"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		Entity e2 = new Entity(p2.getText(), onto.getEntity("DateNumber"), Entity.TYPE_INSTANCE, onto, p2.getBegToken());
		Entity e3 = new Entity(p3.getText(), onto.getEntity("YearNumber"), Entity.TYPE_INSTANCE, onto, p3.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.addLink(new Link("YearValueOf", e3, e0));
		g.setHead(e0);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_date"	// July 14
	salience -100
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length <=2, begToken==p1.endToken)
//		p2: Phrase(synType==null, begToken==p1.endToken, sentence.get(begToken).type == LexToken.LEX_DIGIT)
		(not Phrase(synType=="TIMEP", graph.head.isKindOf("DateValue"), begToken==p1.begToken))
	then
		ut.print("Find month_date: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = p1.getGraph().getHead();// month
		Entity e2 = new Entity(p2.getText(), new Entity("DateNumber", onto), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("DateValueOf", e2, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "month_year"	// October 2010
	salience -100
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, graph.head.isKindOf("MonthName"))
		p2: Phrase(synType=="NUMP", graph.head.isKindOf("NumberValue"), graph.head.name.length ==4, begToken==p1.endToken)
//		p2: Phrase(synType==null, begToken==p1.endToken, sentence.get(begToken).type == LexToken.LEX_DIGIT)
		(not Phrase(synType=="TIMEP", graph.head.isKindOf("DateValue"), begToken==p1.begToken))
	then
		ut.print("Find month_date: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph();
		Entity e0 = new Entity("MonthDateValue", onto);
		Entity e1 = p1.getGraph().getHead();// month
		Entity e2 = new Entity(p2.getText(), new Entity("DateNumber", onto), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		g.addLink(new Link("MonthValueOf", e1, e0));
		g.addLink(new Link("YearValueOf", e2, e0));
		g.setHead(e0);
		Phrase ph = new Phrase(p1, p2, "TIMEP", g);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Weekday_Monthday_1"
	when
		p1: Phrase(synType=="TIMEP", graph.links==null, head.isKindOf("DayOfWeek"))
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolComma"), begToken==p1.endToken)
		p3: Phrase(synType=="TIMEP", head.isKindOf("MonthDateValue"), begToken==p2.endToken)
	then
		ut.print("Find Weekday_Monthday_1: " + p1 + ", " + p2 + ", " + p3);
		Link r = new Link("DayOfWeekOf", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p2, p3, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "Two_Bracket_Serial"
	when
		p1: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolLeftBracket"))
		p2: Phrase(synType=="NUMP", head.isKindOf("NumberValue"), begToken==p1.endToken)
		p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolRightBracket"), begToken==p2.endToken)
	then
		ut.print("Find Two_Bracket_Serial: " + p1 + ", " + p2 + ", " + p3);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		ERGraph g = new ERGraph(new Entity(p2.getText(), onto.getEntity("SerialValue"), Entity.TYPE_INSTANCE, onto, p2.getBegToken()));
		Phrase ph = new Phrase(pl, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end


rule "One_Bracket_Serial"
	when
		p2: Phrase(synType=="NUMP", text.length()==1, head.isKindOf("NumberValue"))
		p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolRightBracket"), begToken==p2.endToken)
		not Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolLeftBracket"), p2.begToken - endToken < 3 && p2.begToken - endToken >=0)
	then
		ut.print("Find One_Bracket_Serial: " + p2 + ", " + p3);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p2);
		pl.add(p3);
		ERGraph g = new ERGraph(new Entity(p2.getText(), onto.getEntity("SerialValue"), Entity.TYPE_INSTANCE, onto, p2.getBegToken()));
		Phrase ph = new Phrase(pl, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "Serial_NP"
	when
		p1: Phrase(synType=="NUMP", head.isKindOf("SerialValue"), text.length()>1)
		// length>1 to exclude letter serials, such as A,B,C.... Letter serials can only be used in NP_serial: "ROOM D", "DEPT. F" 
		p2: Phrase(synType=="NP", begToken==p1.endToken)
	then
		ut.print("Find Serial_NP: " + p1 + ", " + p2);
		Link r = new Link("hasSerial", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "OrgCo_,_CoTypeSuffix"
	when
		p1: Phrase(synType=="NP", head.isKindOf("OrgCoParty"), graph.containLink("define", null, head)==null)
		(or
			(
				p0: Phrase(synType!=null, text==",", begToken==p1.endToken);
			and
				p2: Phrase(synType=="ORGSUFFIX", head.isKindOf("CoTypeSuffix"), begToken==p0.endToken)
			)
			(
				p0: Phrase(synType=="ORGSUFFIX", head.isKindOf("CoTypeSuffix"), begToken==p1.endToken)
				and
				p2: Phrase(synType=="ORGSUFFIX", head.isKindOf("CoTypeSuffix"), begToken==p1.endToken)
			)
		)
	then
		ut.print("OrgCo_,_CoTypeSuffix: " + p1 + ", " + p2);
		Link r = new Link("hasSuffix", p1.getHead(), p2.getHead());
		Phrase ph;
		if(p0!=p2){
			System.out.println("p0!=p2");
			ph = new Phrase(p1, p0, p2, r, 1);
		}
		else
			ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "OrgCo_,_CoType"
	when
		p1: Phrase(synType=="NP", head.isKindOf("OrgCoParty"))
		p0: Phrase(synType!=null, text==",", begToken==p1.endToken);
		p2: Phrase(synType=="NP", head.isKindOf("CoType"), begToken==p0.endToken
			, lk1: graph.containLink("define", null, head), lk1!=null,lk1.arg1.isKindOf("UsState")
			, lk2: graph.containLink("hasDET", head, null), lk2!=null,lk2.arg2.isKindOf("A")
			)
	then
		ut.print("OrgCo_,_CoType: " + p1 + ", " + p2);
		Link r = new Link("hasOrgType", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "Weekday_Monthday_2"
	when
		p1: Phrase(synType=="TIMEP", graph.topLink==null, head.isKindOf("DayOfWeek"))
		p3: Phrase(synType=="TIMEP", graph.head.isKindOf("MonthDateValue"), begToken==p1.endToken)
	then
		ut.print("Find Weekday_Monthday_2: " + p1 + ", " + p3);
		Link r = new Link("DayOfWeekOf", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p3, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end



rule "abbreviation with dot"
	when
		p1: Phrase(synType=="NP"||synType=="ORGSUFFIX", graph.topLink==null, graph.head.isKindOf("Abbreviation") )
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolDot") , begToken==p1.endToken)
	then
		ut.print("Find abbreviation with dot: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, "Abbreviation", 1);
		insert(ph);
		ut.printPhrase(ph);
end
/*
rule "Document_,_Document"	// COPIES OF THE MOTION, OPERATIVE COMPLAINT, OPPOSITION AND REPLY
	when
		p1: Phrase(synType=="NP", head.isKindOf("Document")
				,graph.containLink("define", null, head) ==null)
//				, graph.topLink == null )
		p2: Phrase(synType!=null, text==","||text=="AND"||text.equalsIgnoreCase(", and"), begToken==p1.endToken);
		p3: Phrase(synType=="NP", head.isKindOf("Document"), begToken==p2.endToken)
	then
		ut.print("Document_,_Document: " + p1 + ", " + p2 +", "+p3 );
		String name = p1.getHead().getName().replaceAll("\\s+", "")  + "_,_" + p3.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/
rule "NP_AND_NP"	//no opposition filed, and, good cause shown
	salience 100
	when
		p1: Phrase(synType=="NP"
			,graph.containLink("hasOwner", head, null) ==null
			,graph.containLink("define", null, head) ==null
			,graph.containLink("ugoerOfProc", head, null) ==null
			,!head.isKindOf("LitigationParty")// for Party_,_party
			)
		p2: Phrase(text==","||text.equalsIgnoreCase("and")||text.equalsIgnoreCase(", and"), synType!=null, begToken==p1.endToken)
		p3: Phrase(synType=="NP", begToken==p2.endToken
			,graph.containLink("hasOwner", head, null) ==null
			,graph.containLink("define", null, head) ==null
			,graph.containLink("ugoerOfProc", head, null) ==null
			,!isSubString(p1)
		)
		eval(p1.similar(p3))
	then
		ut.print("Find NP_AND_NP for:  " + p1 +", "+ p2 +", "+p3 );
		String name = p1.getHead().getName().replaceAll("\\s+", "") + "_AND_" + p3.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "NP_VP_Passive"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive")) !=null, 
				graph.containLink("ugoerOfProc", null, head) ==null)
		exists Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VP_Passive: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "BE_VP_past_Passive"
	when
		p1: Phrase(synType=="VP", head.isKindOf("ProcBe"), !graph.containLinkExcept(head, "hasAttribute", "1"));
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" )
	then
		ut.print("Find BE_VP_past_Passive: " + p1 + ", " + p2 );
		Entity e = onto.getEntity("StatusPassive");
		Link r = new Link("hasAttribute", p2.getHead(), e);
		ERGraph g = p2.getGraph().duplicate();
		g.addLink(r);
		g.setTopLink(r);
		Phrase ph = new Phrase(p1, p2, "VP", g);
		ph.setTense("past");
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_IS_ADJP"	// CASE MANAGEMENT CONFERENCE ON JUN-07-2017 IS OFF CALENDAR
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("ProcBe"));
		p3: Phrase(synType=="ADJP", begToken==p2.endToken)
	then
		ut.print("Find NP_IS_ADJP: " + p1 + ", " + p2 + ", " + p3 );
		Link r12 = new Link("agentOfProc", p1.getHead(), p2.getHead());
		Link r23 = new Link("ugoerOfProc", p3.getHead(), p2.getHead());
		Phrase ph23 = new Phrase(p2, p3, r23, 1);
		ph23.setSubject(p1);
		Phrase ph = new Phrase(p1, ph23, r12, 2);
		ph.setSubject(p1);
//		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), r1, 1);
//		g.setTopLink(r2);
//		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
//		ph.setTense(p0.getTense());
//		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_IS_NP_1"	// Deadline is May 1, 2012
	when
		p1: Phrase(synType=="NP")
		p0: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("ProcBe"));
		p2: Phrase(synType=="NP"||synType=="TIMEP", begToken==p0.endToken, head.isKindOf("EntityValue"))
		r : Link(type=="valueOf", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find NP_IS_NP: " + p1 + ", " + p0 + ", " + p2 );
		Link lk = new Link("valueOf", p2.getHead(), p1.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), lk, 1);
		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
		ph.setTense(p0.getTense());
		ph.setSubject(p1);
			insert(ph);
			ut.printPhrase(ph);
end

rule "NP_IS_NP_2" // the reverse of NP_IS_NP_1: May 1, 2012 is the deadline
	when
		p1: Phrase(synType=="NP"||synType=="TIMEP", head.isKindOf("EntityValue"))
		p0: Phrase(synType=="VP", begToken==p1.endToken, head.isKindOf("ProcBe"));
		p2: Phrase(synType=="NP", begToken==p0.endToken)
		r : Link(type=="valueOf", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_IS_NP: " + p1 + ", " + p0 + ", " + p2 );
		Link lk = new Link("valueOf", p1.getHead(), p2.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), lk, 1);
		Phrase ph = new Phrase(p1, p0, p2, "VP", g);
		ph.setTense(p0.getTense());
		ph.setSubject(p1);
			insert(ph);
			ut.printPhrase(ph);
end

rule "NP_ModifiedBy_VP" // NOTICE requesting Clerk to remove Tara C. Stuart as co-counsel.
	when
		p1: Phrase(synType=="NP", graph.containLink("hasDET", head, null)==null
				, graph.containLink("hasAttribute", head, onto.getEntity("Process"))==null
//				, graph.containLink("ugoerOfProc", head, null)==null
				)
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" || tense=="ing", 
				graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive"))==null,	 // avoid combining "amended answer" + "be filed"
				graph.containLink("ugoerOfProc", null, head)==null	 // order, amending D.I. 49 scheduling order
			)
 
	 //		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" || tense=="ing", graph.containLink("ugoerOfProc", null, head)==null)// use past tense
		exists Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_ModifiedBy_VP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
//		ph.transferLinks("PRPRelation", p2.getHead(), p1.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_VP_past" // "motion filed", not as "NP_Modified_VP", but as inverted order VP, To be further combine in "order judgment entered"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past", 
				graph.containLink("ugoerOfProc", null, head)==null,	
				graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive"))==null	 // avoid "answer" + "be filed", that's "NP_VP_Passive"
			)
 		Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VP_past: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		Link r1 = new Link("invertedOrder", p2.getHead(), p1.getHead());
		ph.getGraph().addLink(r1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Process_ModifiedBy_VP" // RELEASE OF MEDICAL REIMBURSEMENT LIEN FILED BY CLAIMANT CITY AND COUNTY OF SAN FRANCISCO
	when
		p1: Phrase(synType=="NP", begToken==0, head.isKindOf("Process"))
		p2: Phrase(synType=="VP", begToken==p1.endToken, tense=="past" || tense=="ing", 
				graph.containLink("hasAttribute", head, onto.getEntity("StatusPassive"))==null,	 // avoid combining "amended answer" + "be filed"
				graph.containLink("ugoerOfProc", null, head)==null	 // order, amending D.I. 49 scheduling order
			)
	then
		ut.print("Find Process_ModifiedBy_VP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

/*
rule "NP_Transfer_filed_by"
	salience 500
	when
		p1: Phrase(synType=="NP", head.isKindOf("Document"), g: graph, graph.containLink("hasContent", head, null)==null)
		(or
				eval( (g.containLink("byAgent", p1.getHead(), null)==null) && (g.containLink("byAgent", (Entity)null, null) != null))
				eval( !g.containLinkKind("ugoerOfProc", p1.getHead(), onto.getEntity("ProcFileDoc")) && g.containLinkKind("ugoerOfProc", null, onto.getEntity("ProcFileDoc")))
			)
	then
		ut.print("Find NP_Transfer_filed_by: " + p1);
		boolean b = p1.transferFiledBy();
		if(b){
			update(p1);
			ut.printPhrase(p1);
		}
end
*/


rule "TO_VP"
	when
		p1: Phrase(synType=="PARTICLE", head.isKindOf("ToInfinitive"), graph.topLink == null)
		p2: Phrase(synType=="VP", begToken==p1.endToken)// use past tense
	then
		ut.print("Find TO_VP: " + p1 + ", " + p2 );
	   Link r = new Link("ToInfinitive", p1.getHead(), p2.getHead());
		 Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_TOVP" // "time to respond", "motion to strike", NOT "'Notice of motion and motion' to strike", "5 days to answer"
	when
		p1: Phrase(synType=="NP"||synType=="TIMEP", headLast(), graph.containLink("hasOwner", head, null)==null
			, graph.containLink("hasDET", head, null)==null, !isSet())
		p2: Phrase(synType=="PARTICLE", head.isKindOf("ToInfinitive"), g : graph, lk2: graph.topLink,  begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="ToInfinitive")
		eval(g.containLink("agentOfProc", null, lk2.getArg2())==null)
	then
		ut.print("Find NP_TOVP: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
//		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end


rule "ADVP_VP"
	when
		p1: Phrase(synType=="ADVP")
		p2: Phrase(synType=="VP", begToken==p1.endToken, !graph.containLinkNot("hasAttribute", p1.getHead(), null))
	then
		ut.print("Find ADVP_VP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_ADVP"
	when
		p1: Phrase(synType=="NP", !graph.containLinkNot("hasAttribute", p1.getHead(), null))
		p2: Phrase(synType=="ADVP", text.equalsIgnoreCase("only"), begToken==p1.endToken)
	then
		ut.print("Find NP_ADVP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end


rule "NP_VP"	// "The court ordered (the following judgment entered)", "Defendant filed ..."
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", graph.containLink("agentOfProc", null, head)==null
		 	, graph.containLink("invertedOrder", head, null)==null
			, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		Link(type=="agentOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VP: " + p1 + ", " + p2 );
		Link r = new Link("agentOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);// result is VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_VPing"	//"STIPULATION Governing Post-Trial Submissions", "order continuing trial date"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", tense=="ing", graph.containLink("agentOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		r : Link(type=="agentOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VPing: " + p1 + ", " + p2 );
		Link lk = new Link("agentOfProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, lk, 1); // result is NP, This is similar to rule NP_ModifiedBy_VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

/*
rule "VPing_NP_1"	//ORDER CONTINUING TRIAL DATE
	when
		p1: Phrase(synType=="VP", tense=="ing", graph.containLink("agentOfProc", null, head)==null, graph.containLink("ugoerOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null)
		p2: Phrase(synType=="NP", begToken==p1.endToken)
		r : Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPing_NP_1: " + p1 + ", " + p2 );
		Link lk = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, lk, 1); // result is VP, This is similar to rule 
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end
*/
rule "VPing_NP_2"	//documents will be claimed by the FILING party/attorney 
	when
		p1: Phrase(synType=="VP", tense=="ing", graph.containLink("agentOfProc", null, head)==null, graph.containLink("ugoerOfProc", null, head)==null, graph.containLink("byAgent", head, null)==null)
		p2: Phrase(synType=="NP", begToken==p1.endToken)
		r : Link(type=="agentOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPing_NP_2: " + p1 + ", " + p2 );
		Link lk = new Link("agentOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, lk, 2); // result is NP, This is similar to rule NP_ModifiedBy_VP
		ph.setSubject(p1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_have_been_VP"	// have been is opposite of to be
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="ASSISTVB", begToken==p1.endToken)
		p3: Phrase(synType=="VP", tense=="past", begToken==p2.endToken)
	then
		ut.print("Find NP_have_been_VP: " + p1 + ", " + p2 + ", " + p3);
		Link lk = new Link("ugoerOfProc", p1.getHead(), p2.getHead());
		ERGraph g = ERGraph.combine(p1.getGraph(), p3.getGraph(), lk, 2);
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		Phrase ph = new Phrase(pl, "VP", g);
		ph.setSubject(p1);
		ph.setTense("past");
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_NP"	// "strike answer", "quash subpoena", But not "strike answer and quash subpoena"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, !isSet(), graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="NP", graph.containLink("agentOfProc", null, head)==null, 
					graph.containLink("ugoerOfProc", head, null)==null, 
					graph.containLink("re", head, null)==null, begToken==p1.endToken)
		not (
				eval(p1.getEndToken() - p1.getBegToken() > 3) and
				eval(p1.getGraph().containLinkKind("PRPRelation", p1.getHead(), null))
			)
		Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VP_NP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
		if(p1.getTense().equals("past")){
			Link r1 = new Link("hasAttribute", p2.getHead(), p1.getHead());
			Phrase ph1 = new Phrase(p1, p2, r, 2);
			insert(ph1);
			ut.printPhrase(ph1);
		}			
end


rule "VP_set_NP"	// "dismiss or abate action"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, isSet()
			, graph.containLink("ugoerOfProc", null, head)==null
			, lks1: graph.containLinkKindList("hasMember", head, null)
			, lks1 != null)
		p2: Phrase(synType=="NP", graph.containLink("agentOfProc", null, head)==null, 
					graph.containLink("ugoerOfProc", head, null)==null, 
					graph.containLink("re", head, null)==null, begToken==p1.endToken)
		not (
				eval(p1.getEndToken() - p1.getBegToken() > 3) and
				eval(p1.getGraph().containLinkKind("PRPRelation", p1.getHead(), null))
			)
		Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), ((Link)(lks1.get(0))).getArg2().isKindOf(arg2))
		Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), ((Link)(lks1.get(1))).getArg2().isKindOf(arg2))
	then
		ut.print("Find VP_set_NP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
end
rule "NP(VP)_NP"
	when
		p1: Phrase(synType=="NP", lk : graph.topLink, head.isKindOf("Process"), h1:head)
		p2: Phrase(synType=="NP", h2:head, graph.containLink("agentOfProc", head, null)==null, 
					graph.containLink("ugoerOfProc", head, null)==null, begToken==p1.endToken)

		Link(type=="ugoerOfProc", h2.isKindOf(arg1), h1.isKindOf(arg2))
	then
		ut.print("Find NP(VP)_NP: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// NP
		insert(ph);
		ut.printPhrase(ph);
end


rule "VP_AND_VP"	//COMPLY WITH SFLR 2.7B AND PROVIDE COURTESY COPIES OF THE MOTION
	salience 100
	when
		p1: Phrase(synType=="VP")
		p2: Phrase(text.equalsIgnoreCase("and")||text.equalsIgnoreCase(", and"), synType=="CONJ", begToken==p1.endToken)
		p3: Phrase(synType=="VP", begToken==p2.endToken)
//		eval(p1.similar(p3))
	then
		ut.print("Find VP_AND_VP for:  " + p1 +", "+ p2 +", "+p3 );
		String name = p1.getHead().getName().replaceAll("\\s+", "") + "_AND_" + p3.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
/*			Entity h1 = p1.getHead().getTheClass();
			Entity h2 = p3.getHead().getTheClass();
			Entity h3 = h1;
			if(h1.isKindOf(h2)){
				h3 = h2;
			} else if(h2.isKindOf(h1)){
				h3 = h1;
			} else {
				h3 = onto.getEntity("Process");
			}  
			ph.getHead().setTheClass(h3);
*/			insert(ph);
			ut.printPhrase(ph);
		}
end


rule "VP_TIMEP"	// summons served JUN-17-2012, conference held MAY-06-2016
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, tense=="past")
		p2: Phrase(synType=="TIMEP", graph.containLink("re", head, null)==null, begToken==p1.endToken)
	then
		ut.print("Find VP_TIMEP: " + p1 + ", " + p2 );
		Link r = new Link("on", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
end

rule "VPP_NP_TIMEP"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="TIMEP", graph.containLink("agentOfProc", null, head)==null, 
					graph.containLink("re", head, null)==null, begToken==p1.endToken)
		exists Link(type=="secondObjectOf", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPP_NP_TIMEP: " + p1 + ", " + p2 );
		Link r = new Link("secondObjectOf", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);	// VP
		insert(ph);
		ut.printPhrase(ph);
end

/**
* this rule is not necessary, because NP_ModifiedBy_VP does the same thing.
rule "NP_VPP"
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType=="VP", tense=="past", graph.containLink("secondObjectOf", null, head)!=null, graph.containLink("byAgent", head, null)==null, begToken==p1.endToken)
		r : Link(type=="ugoerOfProc", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find NP_VPP: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, r, 2);// result is VP
		insert(ph);
		ut.printPhrase(ph);
end
*/

rule "VP_VP_attachToAgent"	// "John start working"
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, subject != null)
		p2: Phrase(synType=="VP", graph.containLink("agentOfProc", null, head)==null, tense=="ing", begToken==p1.endToken)
		exists Link(type=="agentOfProc", p1.subject.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find VP_VP_attachToAgent: " + p1 + ", " + p2 );
		Link r = new Link("agentOfProc", p1.getSubject().getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_VP_attachToVerb"	// "John tasked rule making"
// if cannot be attached to agent, then to verb
	salience -200
	when
		p1: Phrase(synType=="VP", lk : graph.topLink, subject != null)
		p2: Phrase(synType=="VP", graph.containLink("agentOfProc", null, head)==null, tense=="ing", begToken==p1.endToken)
		not Link(type=="agentOfProc", p1.subject.head.isKindOf(arg1), p2.head.isKindOf(arg2))
	then
		ut.print("Find VP_VP_attachToVerb: " + p1 + ", " + p2 );
		Link r = new Link("hasProc", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_object_VPed"	// "THE COURT ORDERED THE FOLLOWING JUDGMENT ENTERED"
	when
		p1: Phrase(synType=="VP", graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="VP", graph.containLink("ugoerOfProc", null, head)!=null, tense=="past", begToken==p1.endToken)
		Link(type=="ugoerOfProc", p2.head.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("VP_object_VPed: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end



rule "TIMEP_define_NP_not_set"	// Defendants' February 9, 2009 letter
	salience -100	
	when
		p1: Phrase(synType=="TIMEP", !graph.containLinkExcept(head, "MonthValueOf", 2, "DateValueOf", 2, "YearValueOf", 2) )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, !isSet())
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
		(not Phrase(synType==null, begToken==p1.begToken, endToken==p2.endToken))//not already created, 
	then
		ut.print("Find TIMEP_define_NP_not_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "Party_Party"	// John D. Smith Kevin H. Spooner
	when
		p1: Phrase(synType=="NP", head.isKindOf("LitigationParty"), graph.containLink("define", null, head) ==null)
		p2: Phrase(synType=="NP", head.isKindOf("LitigationParty"), begToken==p1.endToken, !isSet())
			// !isSet() to reduce combinations.
	then
		ut.print("Party_Party: " + p1 + ", " + p2 );
		String name = p1.getHead().getName().replaceAll("\\s+", "")+ "_" + p2.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(null, p2, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end


rule "Party_,_Party"	// John D. Smith, Kevin H. Spooner
	when
		p1: Phrase(synType=="NP", head.isKindOf("LitigationParty")
				,graph.containLink("define", null, head) ==null
				, graph.topLink == null )
		p2: Phrase(synType!=null, text==","||text=="AND"||text.equalsIgnoreCase(", and"), begToken==p1.endToken);
		p3: Phrase(synType=="NP", head.isKindOf("LitigationParty"), graph.topLink == null, begToken==p2.endToken)
	then
		ut.print("Party_,_Party: " + p1 + ", " + p2 +", "+p3 );
		String name = p1.getHead().getName().replaceAll("\\s+", "")  + "_,_" + p3.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end


rule "NP_,_IfAny_,"	// "provide copies of motions, opposition and reply, if any, to department 501 no later than ... "
				// this should not change HEAD, or anything 
	when
		p1: Phrase(synType=="NP", g1:graph, !isSet())
		p2: Phrase(synType!=null, text==",", begToken==p1.endToken);
		p3: Phrase(synType=="ADJP", head.isKindOf("StatusIfAny"), begToken==p2.endToken)
		p4: Phrase(synType!=null, text==",", begToken==p3.endToken);
	then
		ut.print("NP_,_IfAny_,: " + p1 + ", " + p2 +", "+p3 +", "+p4 );
		List<Phrase> pl = new ArrayList<>();
		pl.add(p1);
		pl.add(p2);
		pl.add(p3);
		pl.add(p4);
		ERGraph g = g1.duplicate();
		Link r = new Link("hasAttribute", p1.getHead(), p3.getHead());
		g.addLink(r);
		Phrase ph = new Phrase(pl, "NP", g);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "NP_define_NP_not_set"	// Defendants'  letter, Rule 16 conference
	salience -100	// generic after specific
	when
//		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define hasAttribute hasMember hasValue", "2 1 1 1") )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, !isSet(), !text.equals(p1.getText()))
		(or
			eval(toplink2==null)
			eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true)
			eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "hasSuffix") == true)
		)
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
//		(not Phrase(synType=="NP", begToken<=p1.begToken, endToken>=p2.endToken))//not already created, 
	then
		ut.print("Find NP_define_NP_not_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_define_NP_set"
	salience -100	// generic after specific
	when
		p1: Phrase(synType=="NP", !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p2: Phrase(synType=="NP", begToken==p1.endToken, toplink2 : graph.topLink, isSet(), ph0 : subphrases.get(0), ph1 : subphrases.get(subphrases.size()-1))
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		exists Link(type=="define", p1.head.isKindOf(arg1), p2.head.isKindOf(arg2))
		not (
			eval(ph1.getGraph().containLink("define", null, ph1.getHead()) != null) and
			eval(ph0.getGraph().containLink("define", null, ph0.getHead()) == null)
		)
		(not Phrase(synType==null, begToken==p1.begToken, endToken==p2.endToken))//not already created, 
	then
		ut.print("Find NP_define_NP_set: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		ph.transferLinks("hasAttribute", p1.getHead(), p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "TIMEP_MEETING"
	when
		p1: Phrase(synType=="TIMEP", graph.topLink ==null )	// Sept. 6 meeting
		p2: Phrase(synType=="NP", head.isKindOf("Meeting"), begToken==p1.endToken, toplink2 : graph.topLink)
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") == true))
		(not Phrase(synType=="NP", begToken==p1.begToken, endToken==p2.endToken))//not already created
	then
		ut.print("Find TIMEP_MEETING: " + p1 + ", " + p2 );
		Link r = new Link("define", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
			insert(ph);
			ut.printPhrase(ph);
end

rule "'s_toPos"
	when
		p1: Phrase(synType=="SYMBOL", text=="'");
		p2: Phrase(synType==null, text=="s"||text=='S', begToken==p1.endToken);
	then
		ut.print("Find 's_toPos: " + p1 + ", " + p2 );
		ERGraph g = new ERGraph(new Entity("SymbolPossess", onto));
		Phrase ph = new Phrase("'s", "POS_SYMBOL", g, p1.getBegToken(), p2.getEndToken(), p1.getSentence());		
		insert(ph);
		ut.printPhrase(ph);
end
 
rule "Comma_And"
	when
		p1: Phrase(synType=="SYMBOL", text==";"|| text==",");
		p2: Phrase(synType!=null, text=="and", begToken==p1.endToken);
	then
		ut.print("Find Comma_And: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 2);		
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_'s_as_POS"	// Counterclaim Plaintiff Motorola, Inc.'s
	when
		p1: Phrase(synType=="NP", leafPhraseCount() < 8, !graph.containRelatedLinkExcept(head, "define hasAttribute hasMember", "2 1 1") )
		p2: Phrase(synType=="POS_SYMBOL", begToken==p1.endToken);
	then
		ut.print("Find NP_'s_as_POS: " + p1 + ", " + p2 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		Phrase ph = new Phrase(pl, "POS", p1.getGraph());
		insert(ph);
		ut.printPhrase(ph);
end
rule "NPs'_as_POS"
	when
		p1: Phrase(synType=="NP", text.endsWith("s")||text.endsWith("S"), headLast(), head.isKindOf("IntelAgent"), !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		p2: Phrase(synType=="SYMBOL", text=="'", begToken==p1.endToken);
	then
		ut.print("Find NPs'_as_POS: " + p1 + ", " + p2 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		Phrase ph = new Phrase(pl, "POS", p1.getGraph());
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP(s)"	// dependant(s)
	when
		p1: Phrase(synType=="NP", graph.topLink==null )
		p2: Phrase(synType!=null, text.equalsIgnoreCase("(s)"), begToken==p1.endToken);
	then
		ut.print("NP(s): " + p1 + ", " + p2 );
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		Phrase ph = new Phrase(pl, "NP", p1.getGraph());
		insert(ph);
		ut.printPhrase(ph);
end


rule "NPs_as_POS"
// this is to accommodate error. Plaintiff's motion => Plaintiffs motion
	when
		p1: Phrase(synType=="NP", text.endsWith("s")||text.endsWith("S"), headLast(), head.isKindOf("IntelAgent"), !graph.containLinkExcept(head, "define", 2, "hasAttribute", 1, "hasMember", 1) )
		not Phrase(synType=="SYMBOL", text=="'", begToken==p1.endToken);
	then
		ut.print("Find NPs_as_POS: " + p1 );
		Phrase ph = p1.clone();
		ph.setSynType("POS");
		insert(ph);
		ut.printPhrase(ph);
end

rule "POS_NP"
// possesive
	when
		p1: Phrase(synType=="POS")
		p2: Phrase(synType=="NP", begToken==p1.endToken, !head.isKindOf("IntelAgent"),
				graph.containLink("hasOwner", head, null)==null, graph.containLink("hasDET", head, null)==null)
	then
		ut.print("Find POS_NP: " + p1  + ", " + p2 );
		Link r = new Link("hasOwner", p2.getHead(), p1.getHead());
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p1);
		pl.add(p2);
		ERGraph g = ERGraph.combine(p1.getGraph(), p2.getGraph(), r, 2);
		Phrase ph = new Phrase(pl, "NP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "PRP_NP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType=="NP"||synType=="TIMEP", begToken==p1.endToken)
	then
		ut.print("Find PRP_NP: " + p1 + ", " + p2 );
		Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "PRP_VP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType=="VP", tense=="ing", begToken==p1.endToken)
	then
		ut.print("Find PRP_VP: " + p1 + ", " + p2 );
		Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NP_NUMP"	// "DEPT. 206" "DEPT. A"
	when
		p1: Phrase(synType=="NP", head.isKindOf("OrgHierarchy"), graph.topLink == null)
		p2: Phrase((synType=="NUMP" && head.isKindOf("NumberValue"))||synType=="LETT", graph.topLink == null, begToken==p1.endToken) 
	then
		ut.print("Find NP_NUMP: " + p1 + ", " + p2 );
		Link r = new Link("numberIdentified", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end
	
rule "NP_PRP_headLast"
	when
		//"DISMISSAL OF COMPLAINT WITH PREJUDICE" will not work because of "headLast()" 
		p1: Phrase(synType=="NP", lk : graph.topLink, g1 : graph, headLast(), lk1 : graph.containLink("hasMember", head, null)
		//, graph.prpCount <3
				, graph.containLink("hasDET", head, null)==null
//				, graph.containLink("ugoerOfProc", head, null)==null
				, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), hd2:head
				, graph.topLink != null, graph.topLink.getType()=="PRPRelation", lk2: graph.topLink, begToken==p1.endToken)
		// cannot have same PRP twice (except "for"):
		not(
			eval(!hd2.isKindOf("for") && g1.containLink(lk2.getArg1().getName(), p1.getHead(), null)!=null)
		)
		// onto triple: head_1 PRP head_2:
		lkx : Link(type==p2.getHead().getTheClass().getName(), p1.getHead().isKindOf(arg1), lk2.arg2.isKindOf(arg2))
	then
		ut.print("Find NP_PRP_headLast: " + p1 + ", " + p2 );
		ut.print("lkx: " + lkx);
		Link r = new Link(lk2.getArg1().getTheClass().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

	
rule "NP_PRP_not_headLast"	//MOTION OF DEFENDANT RECOLOGY INC FOR PEREMPTORY DISQUALIFICATION OF ASSIGNED JUDGE
	when
		p1: Phrase(synType=="NP", lk : graph.topLink, g1 : graph, !headLast(), h1:head, lh: lastHead
				, lastPhrase.synType=="NP"||lastPhrase.synType=="ORGSUFFIX"
				, graph.containLink("hasDET", head, null)==null
				, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), h2:head
				, graph.topLink != null, graph.topLink.getType()=="PRPRelation", lk2: graph.topLink, begToken==p1.endToken)
		// onto triple: head_1 PRP head_2: Document	for	Process
		lkx : Link(type==h2.getTheClass().getName(), h1.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		not Link(type==h2.getTheClass().getName(), lh.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		// cannot have same PRP twice (except "for"):
		not(
			eval(!h2.isKindOf("for") && g1.containLink(lk2.getArg1().getName(), h1, null)!=null)
		)
	then
		ut.print("Find NP_PRP_not_headLast: " + p1 + ", " + p2 );
		ut.print("lkx: " + lkx);
		Link r = new Link(lk2.getArg1().getTheClass().getName(), h1, lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(h2);
		insert(ph);
		ut.printPhrase(ph);
end


rule "NP_PRP_SET"
	when
		p1: Phrase(synType=="NP", h1: head, g1 : graph, lk1 : graph.containLink("hasMember", head, null)
				, graph.containLink("hasDET", head, null)==null
				, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", begToken==p1.endToken, head.isKindOf("PRPRelation"), isSet(), !head.isKindOf("of")
				, lks : graph.containLinkList("hasMember", head, null), g2 : graph, h2: head, h2class:head.getTheClass().getName())
		eval(lks.size()>=2 && g1.containLink(h2class, p1.getHead(), null)==null)// no more than one occurrence of same PRP
		lk0: Link(type==h2class, h1.isKindOf(arg1))
	then
		ut.print("Find NP_PRP_SET: " + p1 + ", " + p2 + "==>" + lk0);
		boolean b = false;
		Entity prp0 = lk0.getArg2();
		for(int i=0;i<lks.size();i++){
			Link lk = (Link)lks.get(i);
			Entity prp = lk.getArg2();
			Link lkk = g2.containLink("PRPRelation", prp, null);
			Entity obj = lkk.getArg2();
			ut.print("\tTrying i=" + i + ", obj=" + obj + ", prp0=" + prp0);
			if(obj.isKindOf(prp0)){
				b = true;
				ut.print("\ti=" + i + ", obj=" + obj + ", prp0=" + prp0);
				break;
			}
		}
		if(b){
			Link lk = (Link)lks.get(0);
			Entity prp = lk.getArg2();
			Link lkk = g2.containLink("PRPRelation", prp, null);
			Entity obj = lkk.getArg2();
			Link r = new Link(h2class, h1, obj);
			Phrase ph = new Phrase(p1, p2, r, 1);
			ERGraph g = ph.getGraph();
			for(int i=1;i<lks.size();i++){
				lk = (Link)lks.get(i);
				prp = lk.getArg2();
				lkk = g2.containLink("PRPRelation", prp, null);
				obj = lkk.getArg2();
				r = new Link(h2class, h1, obj);
				g.addLink(r);
			}
			g.remove(h2);
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "NP_PRP_and_PRP"
	when
		p1: Phrase(synType=="NP", lk : graph.topLink, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, begToken==p0.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && !lk2.getArg2().isKindOf("Time"))// TIME is allowed on verb only, ie VP_PRP
		exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
	then
		ut.print("Find NP_PRP: " + p1 + ", " + p0 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end


rule "NP_PRP_VP_ATTACH" // Case associated with lead case.
	when
		p1: Phrase(synType=="NP", lk : graph.containLink("ugoerOfProc", head, null), lk != null, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, lk2 !=null, begToken==p1.endToken)
		not ( exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))) // cannot attach to NP. If it can, NP_PRP will fire
		exists Link(type==p2.head.name, lk.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))	// can attach to Verb
	then
		ut.print("Find NP_PRP_VP_ATTACH: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk.getArg2(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
		ut.printPhrase(ph);
end

rule "NP_PRP_VP_ATTACH_and_PRP"
	when
		p1: Phrase(synType=="NP", lk : graph.containLink("ugoerOfProc", head, null), lk != null, graph.containLink("hasDET", head, null)==null, graph.containLink("hasOwner", head, null)==null)
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isKindOf("of"), lk2: graph.topLink, lk2 !=null, begToken==p0.endToken)
		not ( exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))) // cannot attach to NP. If it can, NP_PRP will fire
		exists Link(type==p2.head.name, lk.arg2.isKindOf(arg1), lk2.arg2.isKindOf(arg2))	// can attach to Verb
	then
		ut.print("Find NP_PRP_VP_ATTACH: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk.getArg2(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
		ut.printPhrase(ph);
end


rule "NP_PRP_of"	// day 9 of trial (graph.containLink("hasValue", head, null))
	when
	   p1: Phrase(synType=="NP", lk : graph.topLink, headLast()||graph.containLink("hasValue", head, null) != null, graph.containLink("hasDET", head, null)==null
	   		, graph.containLink("hasOwner", head, null)==null, !isSet())
		(or 
			eval(lk==null) 
			eval(lk !=null && (!(onto.isKindOf(lk.getType(), "ugoerOfProc") && lk.getArg1().equals(p1.getHead()))))
		)
		p2: Phrase(synType=="PRP", head.isKindOf("of"), lk2: graph.topLink, begToken==p1.endToken, lk2!=null, graph.containLink("hasMember", lk2.getArg2(), null)==null)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		not (
				eval(p1.getHead().isKindOf("Process")) and
				exists Link(type=="ugoerOfProc", lk2.arg2.isKindOf(arg1), p1.head.isKindOf(arg2))
			)
	then
		ut.print("Find NP_PRP_of: " + p1 + ", " + p2 );
		Entity head = p1.getHead();
		Link r = null;
		int headAt = 1;
		Phrase ph;
		if(head.isKindOf("Measure")){
			r = new Link("hasMeasure", lk2.getArg2(), head);
			ph = new Phrase(p1, p2, r, 2);
			ph.getGraph().remove(p2.getHead());
			ph.getGraph().setHead(lk2.getArg2());
			ph.setSynType("NP");
		}
		else{
			r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
			ph = new Phrase(p1, p2, r, 1);
			ph.getGraph().remove(p2.getHead());
		}
			insert(ph);
		ut.printPhrase(ph);
end


rule "Process_of_Ugoer"	// Dismissal of Entire Action
	when
	   p1: Phrase(synType=="NP", head.isKindOf("Process"), lk : graph.topLink)
		(or 
			eval(lk==null) 
			eval(lk !=null && (!(onto.isKindOf(lk.getType(), "ugoerOfProc") && lk.getArg2().equals(p1.getHead()))))
		)
		p2: Phrase(synType=="PRP", head.isKindOf("of"), lk2: graph.topLink, g: graph, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		eval(lk2 != null && g.containLink("ugoerOfProc", lk2.getArg2(), null) ==null)
		Link(type=="ugoerOfProc", lk2.arg2.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find Process_of_Ugoer: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", lk2.getArg2(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "QUANTIFIER_PRP"
// some of the books
	when
		p1: Phrase(synType=="QUANTIFIER")
		p2: Phrase(synType=="PRP", head.isKindOf("of"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && !lk2.getArg2().isKindOf("Time"))
	then
		ut.print("Find QUANTIFIER_PRP: " + p1 + ", " + p2 );
		Entity ehead = lk2.getArg2();
		Link r = new Link("hasAttribute", ehead, p1.getHead());
		ERGraph g = p2.getGraph();
		Entity oldHead = p2.getHead();
		g.setHead(ehead);
		Phrase ph = new Phrase(p1, p2, r, 2);
		g = ph.getGraph();
		g.remove(oldHead);
		insert(ph);
		ut.printPhrase(ph);
end



rule "PRP_or_PRP"
	when
		p1: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null)
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), graph.topLink == null, begToken==p2.endToken)
	then
		ut.print("Find PRP_PRP: " + p1 + ", " + p2+ ", " + p3 );
		Phrase ph = p1.addToSet(p2, p3, "PRPRelation", true);
		if(ph != null){
			insert(ph);
		}
		ut.printPhrase(ph);
end


rule "VP_BE_PRP_PER"//  MOTION FOR LEAVE TO AMEND IS OFF CALENDAR PER THE REQUEST OF THE MOVING PARTY
	when
		p1: Phrase(synType=="VP", g1 : graph, graph.topLink != null, lk1 : graph.topLink, graph.topLink.getType=="hasAttribute")
		p2: Phrase(synType=="PRP", head.getName()=="per", lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation" && lk1!= null)
	then
		ut.print("Find VP_BE_PRP_PER: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getTheClass().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_PRP_to_V"	// "filed, by defendant", "set, for SEP-20-2017"
	when
		p1: Phrase(synType=="VP", g1 : graph, lk1 : graph.containLink("ugoerOfProc", null, head), !isSet())
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		Link(p2.head.isKindOf(type), p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
//		exists Link(type==p2.head.getTheClass().getName(), p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		not (
			eval(g1.containLink("agentOfProc", null, p1.getHead())!=null) and
			eval(p2.getHead().getTheClass().getName().equals("byAgent"))
		)
		not (
			eval(lk1 != null) and
			exists Link(type==p2.getHead().getTheClass().getName(), lk1.arg1.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		)
	then
		ut.print("Find VP_PRP_to_V: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getTheClass().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_PRP_to_UGOER" //Complaint filed with Jury Demand against Amazon.com Inc.
	when//(390:InPersonSchedulingConference) ugoerOfProc (385:ProcSet) ==> topLink
		p1: Phrase(synType=="VP", g1 : graph, lk1 : graph.containLink("ugoerOfProc", null, head), lk1 != null)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), !head.isInstanceOf("re"), lk2: graph.topLink, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		Link(type==p2.head.name, lk1.arg1.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
	then
		ut.print("Find VP_PRP_to_UGOER: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), lk1.getArg1(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		insert(ph);
		ut.printPhrase(ph);
end

rule "VPing_of_UGOER" // "filing of redacted first amended complaint"
	when
		p1: Phrase(synType=="VP", tense=="ing", graph.containLink("ugoerOfProc", null, head)==null)
		p2: Phrase(synType=="PRP", head.isInstanceOf("of"), lk2: graph.topLink, graph.topLink!=null,
				graph.containLink("ugoerOfProc", graph.topLink.getArg2(), null)==null, begToken==p1.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		Link(type=="ugoerOfProc", lk2.arg2.isKindOf(arg1), p1.head.isKindOf(arg2))
	then
		ut.print("Find VPing_of_UGOER: " + p1 + ", " + p2 );
		Link r = new Link("ugoerOfProc", lk2.getArg2(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
		ph.setSynType("NP"); 
		insert(ph);
		ut.printPhrase(ph);
end

rule "Ref_Value"	// ACKNOWLEDGMENT DATE JAN-09-2017
	when
		p1: Phrase(synType=="NP")
		p2: Phrase(synType!=null, begToken==p1.endToken)
		lk: Link(type=="valueOf", p2.getHead().isKindOf(arg1), p1.getHead().isKindOf(arg2)) //DateValue valueOf DateRef
	then
		ut.print("Find Ref_Value: " + p1 + ", " + p2 );
		Link r = new Link("valueOf", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "VP_PRP_and_PRP" //Summons Reissued as to Fandango Inc. c/o CT Corp. and at Los Angeles, CA address
	when
		p1: Phrase(synType=="VP", g1 : graph, graph.topLink != null && onto.isKindOf(graph.topLink.getType(), "PRPRelation") )
		p0: Phrase(synType!=null, text=="and", begToken==p1.endToken)
		p2: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), lk2: graph.topLink, begToken==p0.endToken)
		eval(lk2 != null && lk2.getType()=="PRPRelation")
		exists Link(type==p2.head.name, p1.head.isKindOf(arg1), lk2.arg2.isKindOf(arg2))
		not (
				eval(g1.containLink("agentOfProc", null, p1.getHead())!=null) and
				eval(p2.getHead().getName().equals("byAgent"))
			)
	then
		ut.print("Find VP_PRP: " + p1 + ", " + p2 );
		Link r = new Link(lk2.getArg1().getName(), p1.getHead(), lk2.getArg2());
		Phrase ph = new Phrase(p1, p0, p2, r, 1);
		ph.getGraph().remove(p2.getHead());
			insert(ph);
		ut.printPhrase(ph);
end

rule "ADJP_NP"
	when
		p1: Phrase(synType=="ADJP" ||synType=="QUANTIFIER"  )
		p2: Phrase(synType=="NP", begToken==p1.endToken, !isSet(), toplink2 : graph.topLink)
		(or eval(toplink2==null) eval(toplink2 !=null && onto.isKindOf(toplink2.getType(), "compoundRelation") ))
	then
		ut.print("Find ADJP_NP: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

/** limited use for not important DE, summons issued etc.

rule "parallel_3_phrase"
	salience -1000
	when
		p1: Phrase(synType!=null);
		p2: Phrase(synType=="SYMBOL", head.name=="SymbolSemicolon", begToken==p1.endToken)
		p3: Phrase(synType!=null, begToken==p2.endToken)
		p4: Phrase(synType!=null, begToken==p3.endToken)
		p5: Phrase(synType!=null, begToken==p4.endToken)
		p6: Phrase(synType=="SYMBOL", head.name=="SymbolSemicolon"||head.name=="SymbolDot", begToken==p5.endToken)
		not Phrase(subphrases != null, subphrases.contains(p1))
		not Phrase(begToken <= p3.begToken, endToken >= p5.endToken)
		eval(p1.lastPhrases(p3, p4, p5) != null)
	then
		List<Phrase> list = p1.lastPhrases(p3, p4, p5);
		int index = list.get(0).getBegToken();
		List<Phrase> pl = new ArrayList<Phrase>();
		pl.add(p3);
		pl.add(p4);
		pl.add(p5);
		List<Phrase> px = p1.joinParse(index, pl);
		ut.print("Find parallel_3_phrase for:  " + p1 +", "+ p2 +", "+p3 +", "+p4 +", "+p5 +", " +p6 + "\n\n");
		if(px != null){
			Phrase ph = new Phrase(p1, px.get(0), (Link)null, 0);
			ph.setComposite(true);
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

/* Too costly and having trouble handle unexpected. Like 

99565	1:09-cv-00651-LPS
serial: 104
	D.I. 70	
NOTICE OF SERVICE of BRISTOL-MYERS SQUIBB CO. AND BRISTOL-MYERS SQUIBB PHARMA CO.S RESPONSES AND OBJECTIONS TO DEFENDANTS FIRST SET OF INTERROGATORIES TO PLAINTIFFS and BRISTOL-MYERS SQUIBB CO. AND BRISTOL-MYERS SQUIBB PHARMA CO.S RESPONSES AND OBJECTIONS TO DEFENDANTS FIRST REQUEST FOR PRODUCTION OF DOCUMENTS AND THINGS TO PLAINTIFFS by Bristol-Myers Squibb Co., Bristol-Myers Squibb Pharma Co., Merck & Co., Inc., Merck Sharp & Dohme Corp..(Stover, Chad) (Entered: 08/16/2010)


rule "and_phrases"
	salience -1000
	when
		p1: Phrase(synType!=null && synType!="EMPTY" );
		p2: Phrase(begToken==p1.begToken, endToken > p1.endToken)
		p3: Phrase(synType!=null, text.equalsIgnoreCase("and"), begToken==p2.endToken)
		p4: Phrase(synType!=null, begToken==p3.endToken)
		not Phrase(begToken <= p1.begToken, endToken >= p4.endToken)
	then
		List<Phrase> px = p1.joinParse(p4);
		ut.print("Find and_phrases for:  " + p1 +", "+ p2 +", "+p3 +", "+p4 + "\n\n");
		if(px != null ){
			Phrase ph = new Phrase(p1, px.get(0), (Link)null, 0);
			ph.setComposite(true);
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

rule "find top phrases"
	salience -10010
	when
		p1: Phrase(synType != null, synType != "SYMBOL")
		(not Phrase(subphrases != null, subphrases.contains(p1)))
//		(not Phrase(begToken <= p1.getBegToken(), endToken >= p1.getEndToken(), (endToken - begToken) > (p1.getEndToken() - p1.getBegToken())))
		(not Phrase(
			(begToken < p1.getBegToken() && endToken >= p1.getEndToken())
			||
			(begToken <= p1.getBegToken() && endToken > p1.getEndToken())
			)
		)
	then
		ut.print("Top phrase:  " + p1);
		ut.print(p1.getBegToken() + ", " + p1.getEndToken());
//			ut.printPhrase(p1);
//		ut.print(p1.getGraph().toGraph());
end


rule "Collection_OR_PRP"//"FOR STATUS OF AMENDED COMPLAINT OR FOR TRIAL SETTING"
	salience 100
	when
		p1: Phrase(synType=="PRP", lk1: graph.topLink)
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType=="PRP", synType==p1.getSynType(), begToken==p2.endToken, lk2: graph.topLink)
		eval(lk1 != null && lk2 != null && lk1.getType()=="PRPRelation" && lk2.getType()=="PRPRelation")
		eval(lk2.getArg1().getName().equalsIgnoreCase(lk1.getArg1().getName()))
	then
		ut.print("Find Collection_OR_PRP for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, (p1 +"_OR_"+p3).replaceAll("\\s+", ""), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

rule "Collection_OR"//"answer/response"
	salience 100
	when
		lk: Link(arg2.name=="CollectionClass", type=="subclassOf");
		p1: Phrase(synType!=null&&synType!="VP", graph.topLink == null, head.isKindOf(lk.getArg1())); 
		p2: Phrase(synType !=null, text=="/"||head.isKindOf("ConjOr"), begToken==p1.endToken)
		p3: Phrase(synType!=null&&synType!="VP", synType==p1.getSynType(), begToken==p2.endToken, graph.topLink == null, head.isKindOf(lk.getArg1()))
		not( exists (Link(this != lk, arg2.name=="CollectionClass", type=="subclassOf", arg1.isKindOf(lk.arg1), p1.head.isKindOf(arg1), p2.head.isKindOf(arg1))))
		eval(p1.similar(p3))
	then
		ut.print("Find collection_OR for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, p1+"_" + p2 +"_"+p3, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end



rule "VP_collection"
	salience 100
	when
		p1: Phrase(synType=="VP", graph.topLink == null);
		p2: Phrase(synType !=null, text=="/"||text.equalsIgnoreCase("or"), begToken==p1.endToken)
		p3: Phrase(synType=="VP", tense==p1.getTense(), graph.topLink == null, begToken==p2.endToken)
	then
		ut.print("Find VP_collection for:  " + p1 +", "+ p2 +", "+p3 );
		String name = p1.getHead().getName() + "_" + p2.getText() + "_" +p3.getHead().getName();
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

/*
rule "Collection_Range" //"07-2017"
	salience 100
	when
		p1: Phrase(synType!=null, graph.topLink == null, head.isKindOf("EntityValue"));
		p2: Phrase(synType=="SYMBOL", head.isKindOf("SymbolHyphen"), begToken==p1.endToken)
		p3: Phrase(synType!=null, p1.synType==synType, graph.topLink == null, head.isKindOf("EntityValue"), begToken==p2.endToken)
	then
		ut.print("Find Collection_Range for:  " + p1 +", "+ p2 +", "+p3 );
		Phrase ph = p1.addToSet(p2, p3, p1.getHead().getName(), true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

rule "combine_identical_phrases"
	salience 1001
	when
		p1: Phrase(synType != null); 
		p2: Phrase(synType != null, begToken==p1.begToken, endToken==p1.endToken)
		eval(p1 != p2 && p1.equivalent(p2))
	then
		ut.print("combine_identical_phrases, removing: " + p2);
		retract(p2);
end

rule "AppearanceOfAttorney_infer_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
 //	   eval(lastph!= null ("Attorney"))
		p3: Phrase(synType != null, begToken > p1.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2) 
		not Phrase(synType != null, begToken < p3.begToken, endToken > p3.begToken)
		not Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
				eIndex --;
				etk = tks.get(eIndex);
			}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
//		System.err.println("identify attorney name: " + namepart);
		List<String> names = EntType.BreakNames(namepart);
		for(String name : names){
			onto.createNewPerson(name, "Attorney", onto, drools.getWorkingMemory());
//			System.err.println(name);
		}
end

rule "AppearanceOfAttorney_infer_name_2"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lk : graph.topLink, graph.topLink != null)
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
		p2: Phrase(synType!=null, text==";"|| text==","|| head.isKindOf("ConjAnd"), begToken==p1.endToken)
		p3: Phrase(synType != null, begToken > p2.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_2: " + p1 + ", " + p2 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		// check junk got suspected as name parts:
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("esq") || txt.equals("filed") || txt.equals("by")||txt.equals("esquire")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String namepart = sent.substring(btk.getStart(), etk.getStart());
			onto.createNewPerson(namepart, "Attorney", onto, drools.getWorkingMemory());
		}
end

rule "AppearanceOfAttorney_infer_name_3"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
 //	   eval(lastph!= null ("Attorney"))
		p3: Phrase(synType != null, text.equalsIgnoreCase("of"), begToken > p1.endToken + 1)
		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
		not Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_name_3: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
			eIndex --;
			etk = tks.get(eIndex);
		}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "Attorney", onto, drools.getWorkingMemory());
end

rule "AppearanceOfAttorney_infer_lawfirm_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcProHacViceAppearance"), lastPhrase.text.equalsIgnoreCase("attorney"), lk : graph.topLink, graph.topLink != null);
		eval(lk.getArg1()==p1.getHead() && lk.getArg2().isKindOf("Attorney"))
		p2: Phrase(synType == "NP", head.isKindOf("Human"));
		p3: Phrase(synType != null, text.equalsIgnoreCase("of"), begToken == p2.endToken)
		p4: Phrase(synType != null, begToken > p3.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
		not Phrase(synType != null, begToken >= p3.endToken, endToken <= p4.begToken, endToken - begToken >= 2)
		not Phrase(synType != null, text.equalsIgnoreCase("of"), begToken >= p3.endToken, endToken <= p4.begToken)
	then
		ut.print("Find AppearanceOfAttorney_infer_lawfirm_name_1: " + p1 + ";; " + p2 + ";; " + p3 + ";; " + p4);
		List<LexToken> tks = p1.getSentence();
		int bIndex = p3.getEndToken();
		int eIndex = p4.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		int last = eIndex -1;
		LexToken lastTK = tks.get(last);
		if(lastTK.getText().equals(",")){
			eIndex --;
			etk = tks.get(eIndex);
		}
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "Lawfirm", onto, drools.getWorkingMemory());
end

rule "DepositionDeclarationReportOfPeople_infer_name_1"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("Deposition")||head.isInstanceOf("DocLegalDeclaration")||head.isInstanceOf("DocLegalReport"), headLast());
		p2: Phrase(synType == "PRP", text.equalsIgnoreCase("of"), begToken==p1.endToken);
		(or
			p3: Phrase(synType=="PRP", head.isKindOf("PRPRelation"), begToken > p2.endToken + 1,  endToken - begToken >= 2)
			p3: Phrase(synType=="SYMBOL", text=="("||text=="]", begToken > p2.endToken + 1) 
		)
		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
		not Phrase(synType =="SYMBOL",begToken >= p2.endToken, endToken <= p3.begToken, text=="("||text=="]"||text==";")
	then
		ut.print("Find DepositionDeclarationReportOfPeople_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("esq") || txt.equals("filed") || txt.equals("by")||txt.equals("esquire")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String namepart = sent.substring(btk.getStart(), etk.getStart());
			String nl = namepart.toLowerCase();
			if(!(nl.contains("plaintiff") ||nl.contains("defendant") ||nl.contains("mailing"))){
				onto.createNewPerson(namepart, "OtherPerson", onto, drools.getWorkingMemory());
			}
		}
end

rule "CorporateParent_infer_name_1" //Corporate Parent Shionogi & Co. Ltd. for Sciele Pharma Inc.
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("CorporateParent"), headLast());
		p3: Phrase(synType=="PRP", head.isKindOf("for"), begToken > p1.endToken + 1,  endToken - begToken >= 2)
		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find CorporateParent_infer_name_1: " + p1 + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		onto.createNewPerson(namepart, "OrgCo", onto, drools.getWorkingMemory());
end

rule "Judge_infer_name_1" //Case assigned to Judge Joseph J. Farnan, Jr. Please include the initials
	salience -2000
	when
		p1: Phrase(synType == "NP", text.equalsIgnoreCase("Judge"));
		p2: Phrase(text.length > 1, begToken > p1.endToken, begToken - p1.endToken < 7);	// avoid the dot after initial, like "J."
//		(or
//			p3: Phrase(synType=="VP", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
//			p3: Phrase(synType=="PRP", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
			p3: Phrase(synType=="SYMBOL", head.isInstanceOf("SymbolDot"), begToken == p2.endToken)
//		)
		not Phrase(synType == "VP"||synType == "PRP", begToken >= p1.endToken, endToken <= p2.begToken)
		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find Judge_infer_name_1: " + p1 + ";; " + p2 + ";; " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getEndToken();
		int eIndex = p2.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
//		ut.print("name: " + namepart);
		onto.createNewPerson(namepart, "Judge", onto, drools.getWorkingMemory());
end


rule "IssueSubpoena_infer_name_1"
	salience -1020
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("ProcIssueDoc")||head.isInstanceOf("ProcServeDoc"), lk : graph.topLink, lk != null, lk.arg1==head, lk.arg2.isInstanceOf("DocLegalSubpoena"));
		p2: Phrase(synType == "PRP", text.equalsIgnoreCase("on")||text.equalsIgnoreCase("upon"), begToken==p1.endToken);
		p3: Phrase(synType=="PRP", head.isInstanceOf("byAgent"), begToken > p2.endToken + 1,  endToken - begToken >= 2)
		not Phrase(synType != null, begToken >= p2.endToken, endToken <= p3.begToken, endToken - begToken >= 2)
	then
		ut.print("Find IssueSubpoena_infer_name_1: " + p1 + ", " + p2  + ", " + p3 );
		List<LexToken> tks = p1.getSentence();
		int bIndex = p2.getEndToken();
		int eIndex = p3.getBegToken();
		LexToken btk = tks.get(bIndex);
		LexToken etk = tks.get(eIndex);
		String sent = btk.parent;
		String namepart = sent.substring(btk.getStart(), etk.getStart());
		if(EntType.isOrgCo(namepart)){
			onto.createNewPerson(namepart, "OrgCo", onto, drools.getWorkingMemory());
		} else {
			onto.createNewPerson(namepart, "OtherPerson", onto, drools.getWorkingMemory());
		}
end


rule "DET_NP"
	when
		p1: Phrase(synType == "DET");
		p2: Phrase(synType == "NP", begToken==p1.endToken,graph.containLink("hasDET", head, null) ==null)
	then
		ut.print("Find DET_NP: " + p1 + ", " + p2 );
		Link r = new Link("hasDET", p2.getHead(), p1.getHead());
		Phrase ph = new Phrase(p1, p2, r, 2);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NumberClass_NumberValue"	// Number 788,200
	when
		p1: Phrase(synType == "NP", head.isKindOf("NumberClass"));
		p2: Phrase(synType == "NUMP", begToken==p1.endToken)
	then
		ut.print("Find NumberClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "NumberValue_SerialValue"	// 2031.285
	when
		p1: Phrase(synType == "NUMP", head.isKindOf("NumberValue")||head.isKindOf("SerialValue"));
		p2: Phrase(synType == "NUMP", head.isKindOf("NumberValue")||head.isKindOf("SerialValue"), begToken==p1.endToken);
	then
		ut.print("Find NumberValue_SerialValue: " + p1 + ", " + p2);
		Entity e = new Entity(p1.getText()+p2.getText(), onto.getEntity("SerialValue")
			, Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		ERGraph g = new ERGraph(e);
		Phrase ph = new Phrase(p1, p2, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "NumberValue_._NumberValue"	// 2031.285
	when
		p1: Phrase(synType == "NUMP", head.isKindOf("NumberValue"));
		p2: Phrase(synType == "SYMBOL", text==".", begToken==p1.endToken)
		p3: Phrase(synType == "NUMP", head.isKindOf("NumberValue"), begToken==p2.endToken);
	then
		ut.print("Find NumberValue_._NumberValue: " + p1 + ", " + p2 + ", " + p3);
		Entity e = new Entity(p1.getText().trim()+p2.getText()+p3.getText().trim(), onto.getEntity("NumberValue")
			, Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		ERGraph g = new ERGraph(e);
		Phrase ph = new Phrase(p1, p2, p3, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "MoneySymbol_MoneyValue"	// $ 455.00
	when
		p1: Phrase(synType == "SYMBOL", head.isInstanceOf("SymbolDollar"));
		p2: Phrase(synType == "NUMP", begToken==p1.endToken)
	then
		ut.print("Find MoneySymbol_MoneyValue: " + p1 + ", " + p2 );
		int tkpos = p1.getBegToken();
		List<LexToken> tks = p1.getSentence();
		LexToken bk = tks.get(tkpos);
		int offset = bk.getStart();
		String sent = bk.parent;
		int endT = p2.getEndToken();
		LexToken ek = tks.get(endT-1);
		int endOffset = ek.getEnd();
		String txt = sent.substring(offset, endOffset);
		ERGraph g = new ERGraph(new Entity(txt, onto.getEntity("MoneyValue"), Entity.TYPE_INSTANCE, onto, p1.getBegToken()));
		Phrase ph = new Phrase(txt, "NP", g, p1.getBegToken(), p2.getEndToken(), tks);
		insert(ph);
		ut.printPhrase(ph);	
end

rule "Bracket_Lett"	// (D)
	when
		p1: Phrase(synType == "SYMBOL", text=="(");
		p2: Phrase(synType == "LETT", begToken==p1.endToken)
		p3: Phrase(synType == "SYMBOL", text==")", begToken==p2.endToken);
	then
		ut.print("Find Bracket_Lett: " + p1 + ", " + p2 + ", " + p3 );
		Phrase ph = new Phrase(p1, p2, p3, "LETT", p2.getGraph());
		insert(ph);
		ut.printPhrase(ph);	
end

rule "SerialClass_NumberValue"	// Number 788,200, Rule 16.2b Scheduling Teleconference
	when
		p1: Phrase(synType == "NP", head.isKindOf("SerialClass"), graph.links==null);
		p2: Phrase(synType == "NUMP"||synType == "LETT", begToken==p1.endToken)
	then
		ut.print("Find SerialClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);	
/**
		r = new Link("define", p1.getHead(), p2.getHead());
		ph = new Phrase(p1, p2, r, 2);
		ph.setSynType("NUMREF");
		insert(ph);
		ut.printPhrase(ph);	
*/
end

rule "SerialClass_SerialClass_NumberValue"	// CODE OF CIVIL PROCEDURE, SECTION 2031.285(D)(1).
	when
		p1: Phrase(synType == "NP", head.isKindOf("SerialClass"), headLast());
		p2: Phrase(synType == "NP", head.isKindOf("Section"), begToken==p1.endToken, lk:graph.topLink);
			eval(lk!=null && lk.getType().equals("hasValue"))
	then
		ut.print("Find SerialClass_SerialClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "SerialClass_,_SerialClass_NumberValue"	// CODE OF CIVIL PROCEDURE, SECTION 2031.285(D)(1).
	when
		p1: Phrase(synType == "NP", head.isKindOf("SerialClass"), graph.links==null);
		p0: Phrase(synType == "SYMBOL", text==".");
		p2: Phrase(synType == "NP", head.isKindOf("Section"), begToken==p1.endToken, lk:graph.topLink);
			eval(lk!=null && lk.getType().equals("hasValue"))
	then
		ut.print("Find SerialClass_,_SerialClass_NumberValue: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NumberValue_Lett"	// Number 788,200, Rule 16.2b Scheduling Teleconference
	when
		p1: Phrase(synType == "NUMP")
		p2: Phrase(synType == "LETT", begToken==p1.endToken)
	then
		ut.print("Find NumberValue_Lett: " + p1 + ", " + p2 );
		Entity en = new Entity(p1.getText() + p2.getText(), onto.getEntity("SerialValue"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		ERGraph g = new ERGraph(en);
		Phrase ph = new Phrase(p1, p2, "NUMP", g);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NumberValue_TimeRef"	// 2.0 Days
	when
		p1: Phrase(synType == "NUMP", g1:graph, head.isKindOf("NumberValue"))
		p2: Phrase(synType == "NP", g2:graph, head.isKindOf("TimeRef"), graph.links==null, begToken==p1.endToken);
	then
		ut.print("Find NumberValue_TimeRef: " + p1 + ", " + p2 );
		Entity en = new Entity(p1 + " " + p2, onto.getEntity("TimeQuantity"), Entity.TYPE_INSTANCE, onto, p1.getBegToken());
		ERGraph g = new ERGraph(en);
		g.merge(g1);
		g.merge(g2);
		Link r1 = new Link("valueOf", p1.getHead(), en);
		Link r2 = new Link("unitOf", p2.getHead(), en);
		g.addLink(r1);
		g.addLink(r2);
		Phrase pp = new Phrase(p1, p2, "TIMEP", g);
		Phrase ph = new Phrase(pp);
		insert(ph);
		ut.printPhrase(ph);
end

rule "Time_TimeQuantity"	// estimated time for trial: 2.0 Days
	when
		p1: Phrase(synType == "NP", g1:graph, head.isKindOf("TimeRef"))
		p2: Phrase(synType=="SYMBOL", text==":", begToken==p1.endToken) 
		p3: Phrase(synType == "TIMEP", g2:graph, head.isKindOf("TimeQuantity"), begToken==p2.endToken);
	then
		ut.print("Find Time_TimeQuantity: " + p1 + ", " + p2 + ", " + p3 );
		Link r = new Link("valueOf", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p2, p3, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "NumberedClass_NumberClass"
	when
		p1: Phrase(synType == "NP", head.isKindOf("NumberedClass"));
		p2: Phrase(synType == "NP", head.isKindOf("NumberClass"), graph.containLink("hasValue", head, null)!=null, begToken==p1.endToken)
	then
		ut.print("Find NumberedClass_NumberClass: " + p1 + ", " + p2 );
		Link r = new Link("hasValue", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "Order_that"
	when
//		p1: Phrase(synType == "NP", head.isKindOf("DocLegalOrder"), graph.links==null);
		p1: Phrase(synType == "NP", head.isKindOf("Document"), graph.links==null);
		p2: Phrase(synType == "DET", text.equalsIgnoreCase("that"), begToken==p1.endToken)
		p3: Phrase(synType == "VP", graph.links != null, graph.links.size()>3, begToken==p2.endToken)
	then
		ut.print("Find Order_that: " + p1 + ", " + p2 + ", " + p3 );
		Link r = new Link("hasContent", p1.getHead(), p3.getHead());
		Phrase ph = new Phrase(p1, p2, p3, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

rule "re_NUMREF"
	when
		p1: Phrase(synType == "PRP", head.isInstanceOf("re"), graph.topLink==null);
		p2: Phrase((synType=="NUMP" && text.length()<=4) || synType=="NUMREF", head.isKindOf("NumberValue"), begToken == p1.endToken) 
	then
		ut.print("Find re_NUMREF: " + p1 + ", " + p2 );
	   Link r = new Link("PRPRelation", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

// spaces between result in case number having detached parts, just throw them away.
rule "CaseNumber_leftover"	// (65 in 1:09-cv-00131-SLR -MPT, 72 in 1:09-cv-00130-SLR -MPT)
	when
		p1: Phrase(synType == "NP", head.isInstanceOf("CaseNumber"), graph.containLink("hasMember", head, null)==null);
		p2: Phrase(text=="-", begToken == p1.endToken) 
		p3: Phrase(text.length()<=4, text.length() >=2, begToken == p2.endToken) 
	then
		ut.print("Find CaseNumber_leftover: " + p1 + ", " + p2 + ", " + p3 );
		Phrase ph = new Phrase(p1.getText() + p2.getText() + p3.getText(), p1.getSynType(), p1.getGraph(), p1.getBegToken(), p3.getEndToken(), p1.getSentence());
		insert(ph);
		ut.printPhrase(p1);
end

rule "Person_Suffix"
	salience -200
	when
		p1: Phrase(synType == "NP", head.isKindOf("Human"))
		p2: Phrase(synType == "PERSONSUFFIX", begToken==p1.endToken)
//		not Phrase(synType=="NP", begToken<=p1.begToken, endToken>=p2.endToken)
// the following cause infinite loop for case 2000005108 serail 41:
		not Phrase(synType=="NP", head.isKindOf("Human"), begToken<=p1.begToken, endToken>=p2.endToken)
	then
		ut.print("Find Person_Suffix: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "Document_due_date"	// answer due 5/10/2011
	when
		p1: Phrase(synType=="NP", head.isKindOf("Document"))
		p2: Phrase(synType !=null, text.equalsIgnoreCase("due"), begToken==p1.endToken)
		(or
			p3: Phrase(synType=="TIMEP", dat : head, head.isInstanceOf("DateValue"), begToken==p2.endToken)
				p3: Phrase(synType=="PRP", lk : graph.topLink , lk!= null, lk.type=="PRPRelation", lk.arg1.isKindOf("byAgent") || lk.arg1.isKindOf("on")  , dat : graph.topLink.arg2, begToken==p2.endToken)
		)	  
	then
		ut.print("Find document_due_date: " + p1 + ", " + p2 + ", " + p3);
//		Link r = new Link("hasDueDate", p1.getHead(), p3.getHead());
		Link r = new Link("hasDueDate", p1.getHead(), dat);
		Phrase ph = new Phrase(p1, p2, p3, r, 1);
		if(p3.getSynType().equals("PRP")){
				ph.getGraph().remove(p3.getHead());
		}
			insert(ph);
			ut.printPhrase(ph);
end

rule "OrgCo_OrgCoSuffix"	// <=<HOSIE RICE>=> LLP
	when
		p1: Phrase(synType=="NP", head.isKindOf("OrgCoName"))
		p2: Phrase(synType=="ORGSUFFIX", begToken==p1.endToken)
	then
		ut.print("Find OrgCo_OrgCoSuffix: " + p1 + ", " + p2 );
		Link r = new Link("OfOrgCoSuffix", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end

// this is too ambitious, gets too complicated
rule "Collection_2" //"trial, JURY TRIAL", 
	salience 100
	when
		p1: Phrase(synType!=null, g1 : graph); //graph.isSet() == false, 
		p2: Phrase(synType != null, st: synType, head.name != null, nm : head.getTheClass().name, begToken==p1.endToken)
		eval( !g1.containLinkKind("ugoerOfProc", p1.getHead(), (Entity)null) && !g1.containLinkKind("ToInfinitive", p1.getHead(), (Entity)null))
//		(or
			eval(st.equals("SYMBOL") && (nm.equals("SymbolComma") || nm.equals("SymbolSemicolon")))
//			eval(st.equals("CONJ") && nm.equals("ConjAnd"))
//		)
		p3: Phrase(synType!=null, p1.synType == synType, head.isKindOf(p1.head), begToken==p2.endToken, g3 : graph)
		// left side can be a set, not right side: 
		eval( !g3.isSet() && !g3.containLinkKind("ToInfinitive", p3.getHead(), (Entity)null))
		eval(p1.topLinkMatch(p3))
		eval(p3.leafPhraseCount() < 10)
//		don't complicate things for now:
//		eval(p1.hasAttribute("NumberValue") == p3.hasAttribute("NumberValue"))
		(or
			eval(p1.leafPhraseCount() < 10)
			eval(p1.isSet())
		)
		not Phrase(synType != null, begToken <= p1.begToken, endToken >= p3.endToken, head.isKindOf(p1.head) || p1.head.isKindOf(head))
	then
		ut.print("Find collection_2 for:  " + p1 +", "+ p2 +", "+p3 );
		String name = p1.getHead().getName().replaceAll("\\s+", "") + "_,_" + p3.getHead().getName().replaceAll("\\s+", "");
		Phrase ph = p1.addToSet(p2, p3, name, true);
		if(ph != null){
			insert(ph);
			ut.printPhrase(ph);
		}
end

/**
rule "Collection_3"//"complaint , PROOF OF SERVICE"
	salience 100
	when
		lk: Link(arg2.name=="CollectionClass", type=="subclassOf")
		p1: Phrase(synType!=null, gg1 : graph, hd1 : head); //graph.isSet() == false, 
		eval(hd1.isKindOf(lk.getArg1()))
		eval(!gg1.containLinkKind("ugoerOfProc", hd1, (Entity)null) && !gg1.containLinkKind("ToInfinitive", hd1, (Entity)null))
		 
		p2: Phrase(synType!=null, text==";"|| text==","|| head.isKindOf("ConjAnd"), begToken==p1.endToken)
		p3: Phrase(synType!=null, p1.synType == synType, begToken==p2.endToken, gg3 : graph, hd3 : head) // this is taken care of by Collection_2
		eval (!hd3.isKindOf(hd1) && hd3.isKindOf(lk.getArg1()))
		not Link(arg2.name=="CollectionClass", type=="subclassOf", 
					arg1.isKindOf(lk.arg1) && ( !arg1.equals(lk.arg1)),
					hd1.isKindOf(arg1),
					hd3.isKindOf(arg1)
				)		
		eval(!gg3.containLinkKind("ugoerOfProc", p3.getHead(), (Entity)null) && !gg3.containLinkKind("ToInfinitive", p3.getHead(), (Entity)null))
		(or
			eval(!p1.getGraph().containLinkKind("PRPRelation", p1.getHead(), (Entity)null))
			eval(p1.getGraph().containLink("with", p1.getHead(), null) != null) // let "with" be an exception
		)
		(or
			eval(!p3.getGraph().containLinkKind("PRPRelation", p3.getHead(), (Entity)null))
			eval(p3.getGraph().containLink("with", p3.getHead(), (Entity)null) != null) // let "with" be an exception
		)
		not (	// no closer common ancester exists:
			lk2: Link(arg2.name=="CollectionClass", type=="subclassOf") and
			eval(!lk2.equals(lk)) and
			eval(p1.getHead().isKindOf(lk2.getArg1()) && p3.getHead().isKindOf(lk2.getArg1()) ) and
			eval(lk2.getArg1().isKindOf(lk.getArg1()))
		)
		not (	// no even longer phrase exists:
		  Phrase(synType!=null, p1.synType == synType, begToken==p2.endToken, endToken > p3.endToken, gg4 : graph, hd4 : head) and
		  eval(!hd4.isKindOf(hd1) && hd4.isKindOf(lk.getArg1())) and
		  eval( !gg4.containLinkKind("PRPRelation", hd4, (Entity)null) && !gg4.containLinkKind("ugoerOfProc", hd4, (Entity)null) && !gg4.containLinkKind("ToInfinitive", hd4, (Entity)null))
		)
		not Phrase(synType!=null, isSet(), p1.head.isKindOf(head), begToken < p1.begToken, endToken >= p1.endToken)
		eval(p1.leafPhraseCount() < 10)
		(or
			eval(p3.leafPhraseCount() < 10)
			eval(p3.isSet())
		)
		eval(p1.hasAttribute("NumberValue") == p3.hasAttribute("NumberValue"))
	then
		ut.print("Find collection_3 for:  " + p1 +", "+ p2 +", "+p3 );
//		boolean b1 = p1.hasAttribute("NumberValue");
//		boolean b2 = p3.hasAttribute("NumberValue");
//		System.out.println("b1:" + b1 + ", " + "b2: " + b2);
		ERGraph g1 = p1.getGraph();
		ERGraph g2 = p3.getGraph();
		if(g1.topLinkMatch(g2)){
			Phrase ph = p3.addToSet(p2, p1, lk.getArg1().getName(), false);
			if(ph != null){
				insert(ph);
				ut.printPhrase(ph);
			}
		}
end
*/
/*
rule "Number_Document"	// re 23 motion
	when
		p1: Phrase((synType=="NUMP" && text.length()<=4) || synType=="NUMREF", head.isKindOf("NumberValue")) 
//		p2: Phrase(synType=="NP", head.isKindOf("Document"), g: graph,  graph.containLink("hasMember", head, null)==null, begToken==p1.endToken)
		p2: Phrase(synType=="NP", head.isKindOf("Document"), g: graph,  begToken==p1.endToken)
		eval( !g.containLinkKind("PRPRelation", p2.getHead(), (Entity)null) && !g.containLinkKind("ToInfinitive", p2.getHead(), (Entity)null))
//			!graph.containLinkKind("ugoerOfProc", head, (Entity)null),
//			!graph.containLinkKind("PRPRelation", head, (Entity)null),
//			!graph.containLinkKind("ToInfinitive", head, (Entity)null), begToken==p1.endToken
//		)
	then
		ut.print("Find Number_Document: " + p1 + ", " + p2 );
		Entity hd = p2.getHead();
		boolean bNum = false;
		List<Link> lks = g.containLinkList("hasMember", hd, null);
		if(lks != null){
			for(Link lk : lks){
				Entity e2 = lk.getArg2();
				List<Entity> le = g.getModifierList(e2);
				if(le != null){
					for(Entity e : le){
						if(e.isInstanceOf("NumberValue")){
							bNum = true;
							break;
						}
					}
				}
				if(bNum){
					break;
				}
			}
		}
		if(!bNum){
			Link r = new Link("hasAttribute", p2.getHead(), p1.getHead());
			Phrase ph = new Phrase(p1, p2, r, 2);
			insert(ph);
			ut.printPhrase(ph);
		}
end
*/

rule "Document_Number"	// re 23 motion
	when
		p1: Phrase(synType=="NP", head.isKindOf("DocLegalMotion"), g: graph)
		p2: Phrase(synType=="NUMREF", head.isKindOf("NumberValue"),  graph.containLinkKind("define", onto.getEntity("DocketEntryIndex"), head) != null, begToken==p1.endToken) 
//		eval( !g.containLinkKind("PRPRelation", p1.getHead(), (Entity)null) && !g.containLinkKind("ToInfinitive", p1.getHead(), (Entity)null))
	then
		ut.print("Find Document_Number: " + p1 + ", " + p2 );
		Link r = new Link("hasAttribute", p1.getHead(), p2.getHead());
		Phrase ph = new Phrase(p1, p2, r, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule		"remove all phrases"
	salience 10000
	when
		LexFlag(flag==true)
		ph :Phrase()
	then
//	System.out.println("remove phrase: " + ph);
		retract(ph);
end

rule	"count phrases"
	salience 10000
	when
		pc :PhraseCounter()
		ph :Phrase(synType !=null)
	then
		int cnt = pc.incrementPhraseCount();
//		if(cnt % 100 == 0){
//			System.err.println("\nPhraseCount: " + cnt);
			if(cnt >= 5000){
				drools.halt();
			}
//		}
end


rule		"remove LexFlag"
	salience 10000
	when
		lf: LexFlag()
		pc: PhraseCounter()
		not Phrase()
	then
//	System.out.println("remove LexFlag");
//		int cnt = pc.getPhraseCount();
//		System.err.println("Phrase count: " + cnt);
//		ut.print("Phrase count: " + cnt);
		retract(lf);
		retract(pc);
end
/**
rule "remove more phrase"
	salience 10000
	when
		p1 : Phrase(synType != null )
		p2 : Phrase(synType == p1.synType, p1.head.isKindOf(p2.head) || p2.head.isKindOf(p1.head), begToken == p1.begToken, endToken == p1.endToken, entityCount < p1.entityCount)
	then
		ut.print("remove more phrase: " + p1 + "::" + p1.getEntityCount() + " <==> " + p2 + "::" + p2.getEntityCount());
		retract(p1);
end
*/


query "One Phrase longest sentence"
//	ph : Phrase(begToken ==0, synType != null)
	ph : Phrase(begToken ==0, synType != null, synType != "EMPTY")
	(not Phrase(subphrases != null, subphrases.contains(ph)))
	(not Phrase(begToken == 0, endToken > ph.endToken))
end




query "all phrases"
	ph : Phrase(synType != null, synType != "SYMBOL", synType != "EMPTY")
end



rule "OrgCo_Suffix"
	salience -200
	when
		p1: Phrase(synType == "NP", graph.topLink==null, head.isKindOf("OrgCo"))
		p2: Phrase(synType == "ORGSUFFIX", begToken==p1.endToken)
		not (Phrase(synType=="NP", head.isKindOf("OrgCo"), begToken<=p1.begToken, endToken>=p2.endToken))
	then
		ut.print("Find OrgCo_Suffix: " + p1 + ", " + p2 );
		Phrase ph = new Phrase(p1, p2, (Link)null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "OrgCo_Comma_Suffix"
	when
		p1: Phrase(synType=="NP", graph.topLink==null, graph.head.isKindOf("OrgCo") )
		p12: Phrase(synType=="SYMBOL", graph.topLink==null, head.isInstanceOf("SymbolComma"), begToken==p1.endToken  )
		p2: Phrase(synType=="ORGSUFFIX", graph.topLink==null, graph.head.isKindOf("Abbreviation"), begToken==p12.endToken )
		not (Phrase(synType=="NP", head.isKindOf("OrgCo"), begToken<=p1.begToken, endToken>=p2.endToken))
	then
		ut.print("Find OrgCo_Comma_Suffix: " + p1 + ", " + p12 + ", " + p2 );
		Phrase ph = new Phrase(p1, p12, p2, null, 1);
		insert(ph);
		ut.printPhrase(ph);
end


rule "OrgCo_infer_name"
	salience -2000
	when
		p1: Phrase(synType == "NP", head.isKindOf("OrgCo"), !lastPhrase.head.isKindOf("Abbreviation"), graph.links ==null);
//		p3: Phrase(synType != null, begToken > p1.endToken + 1,  endToken - begToken >= 2)	// there are good phrases ahead.
		p3: Phrase(synType=="ORGSUFFIX", head.isKindOf("Abbreviation"), begToken > p1.endToken + 1)
		not Phrase(synType=="ORGSUFFIX", head.isKindOf("Abbreviation"), begToken >= p1.begToken, endToken < p3.begToken)
//		not Phrase(synType != null, begToken >= p1.endToken, endToken <= p3.begToken, endToken - begToken >= 2) 
		not Phrase(synType != null, begToken < p3.begToken, endToken > p3.begToken)
		not Phrase(synType == "PRP", begToken >= p1.endToken, endToken <= p3.begToken)
	then
		ut.print("Find OrgCo_infer_name: " + p1 + ", " + p3 );
		ut.printPhrase(p1);
		ut.printPhrase(p3);
		List<LexToken> tks = p1.getSentence();
		int bIndex = p1.getBegToken();
		int eIndex = p3.getEndToken();
//		System.err.println("bIndex:" + bIndex + ", eIndex: " + eIndex + ", tks.size: " + tks.size());
//		System.err.println("tks: " + tks);
		LexToken btk = tks.get(bIndex);
		// check junk got suspected as name parts:
		boolean hasJunk = false;
		for(int i=bIndex;i<eIndex;i++){
			LexToken tk = tks.get(i);
			String txt = tk.getText().toLowerCase();
			if(txt.equals("filed") || txt.equals("by")){
				hasJunk = true;
				break;
			}
		}
		if(!hasJunk){
			String sent = btk.parent;
			String partyName;
			if(eIndex >= tks.size()){
				partyName = sent.substring(btk.getStart()).trim();
			} else {
				LexToken etk = tks.get(eIndex);
				partyName = sent.substring(btk.getStart(), etk.getStart()).trim();
			}
			ut.print("(" + bIndex + ", " + eIndex + ") " +  partyName);
			onto.createNewParty(partyName, onto, drools.getWorkingMemory(), p1.getHead());
		}
end
